ğŸ‘‹ 31 - DeÄŸiÅŸken Nedir? Bir ProgramcÄ±nÄ±n DeÄŸiÅŸkene Neden Ä°htiyacÄ± Olur?

Bir programcÄ±nÄ±n amacÄ± eldeki verilerle oluÅŸturulan yazÄ±lÄ±mlarÄ±n doÄŸru bir ÅŸekilde iÅŸlenip sonuÃ§lar elde edebilmesidir.

Hangi yazÄ±lÄ±m olursa olsun amaÃ§, burada bir veriyi doÄŸru bir ÅŸekilde iÅŸleyebilmek doÄŸru bir ÅŸekilde iÅŸlerken bu veriyle ilgili operasyonlarÄ± gerÃ§ekleÅŸtirebilmektir.

DeÄŸiÅŸken, bu yazÄ±lÄ±m sÃ¼recinde bir amaca hizmet eden bir yapÄ±lanmadÄ±r.
YazÄ±lÄ±malar veriyi doÄŸru bir ÅŸekilde iÅŸleyip Ã§Ä±ktÄ± veren yapÄ±lanmalardÄ±r.
Burada merkeze veriyi alÄ±rsak bu veri yazÄ±lÄ±mÄ±n neresindedir? Ä°ÅŸte iÅŸlenecek bir veri var ve bunu yazÄ±lÄ±mda bir yerde tutmam lazÄ±m. 

ğŸ‘‰ ! Bilgisayarda ram dediÄŸimiz bir kÄ±sÄ±m var. Ram'e geÃ§ici bellek yada Ã¶nbellek deriz. O anki Ã§alÄ±ÅŸtÄ±ÄŸÄ±mÄ±z verileri Ram'e koyuyoruz. DolayÄ±sÄ±yla iÅŸlem yapma esnasÄ±nda iÅŸlem yapÄ±lan/iÅŸlenen veri Ram'de tutulur.

Ram kendi iÃ§inde bÃ¶lÃ¼mlere ayrÄ±lmÄ±ÅŸ bir yapÄ±lamaya sahiptir.
YazÄ±lÄ±mda biz ÅŸunu yapÄ±yoruz. Diyoruz ki benim elimde 5 diye bir deÄŸer var.
Bu 5 deÄŸerini benim Ram'e koyup oradan daha sonra yazÄ±lÄ±mda iÅŸleyebilmem
gerekiyor. YazÄ±lÄ±m Ram'deki bu 5 deÄŸerini alabiliyor kendi bÃ¼nyesinde iÅŸleyebiliyor yada Ã¼rettiÄŸi 5'i yine Ram'e koyabiliyor.

ğŸ‘‰ ! Yani yazÄ±lÄ±m veri tutmaz. YazÄ±lÄ±m veriyi Ram'den alÄ±r Ram'e yerleÅŸtirir.

ğŸ‘‰ ! YazÄ±lÄ±mda veri tutulamz Ram'de tutulur.

YazÄ±lÄ±m da yapÄ±lacak iÅŸlemlerin en kÃ¼Ã§Ã¼k en merkezi noktasÄ± olan veriyi biz Ram'de tutarÄ±z. 

Bir yazÄ±lÄ±mda iÅŸlenecek veriyi Ram'de tutabilmek iÃ§in deÄŸiÅŸkenler kullanÄ±lÄ±r.

DeÄŸiÅŸken dediÄŸimiz, yazÄ±lÄ±m adÄ±na Ram'e veri koymamÄ±zÄ± ve ihtiyaÃ§ doÄŸrultusunda o Ram'deki veriyi elde etmemizi saÄŸlayan yapÄ±lardÄ±r.

Yani sen bir veriyi iÅŸleyebilmek iÃ§in o veriyi yazÄ±lÄ±ma koyabilmen iÃ§in onu gidip yazÄ±lÄ±m adÄ±na Ram'e koyman lazÄ±m. Ä°ÅŸte o yazÄ±lÄ±m adÄ±na veriyi Ram'e koyan yapÄ±lanmaya deÄŸiÅŸken denir. 

DeÄŸiÅŸken, adÄ± Ã¼stÃ¼nde deÄŸiÅŸen/deÄŸiÅŸken yapÄ±lardÄ±r.

Bir programcÄ± verisini tutabilmek iÃ§in deÄŸiÅŸkene ihtiyaÃ§ duyar. 

ğŸ‘‰ ! Ä°ÅŸlenecek veriler veritabanÄ±nda tutulur doÄŸru ama siz yine bunu iÅŸleme esnasÄ±nda bu verileri Ram'e almanÄ±z gerekecektir. 

ğŸ‘‰ ! Ä°ÅŸlem boyutundayken veritabanÄ±nda bir veriyi iÅŸleyemezsin. Ram'deki veriyi iÅŸleyebilirsin. 

ğŸ‘‰ ! Biz iÅŸ yapÄ±yorsak %100 Ram'de Ã§alÄ±ÅŸmalÄ±yÄ±z. 

Bir yazÄ±lÄ±mÄ±n Ram'de Ã§alÄ±ÅŸabilmesi, Ram'e deÄŸer koyabilmesi, Ram'deki bir deÄŸeri elde edebilmesi iÃ§in deÄŸiÅŸkenleri kullancaÄŸÄ±z. 

DeÄŸiÅŸken bir programcÄ±nÄ±n yazÄ±lÄ±mda iÅŸleyeceÄŸi veriyi Ram'de o program adÄ±na tutabilmesi iÃ§in kullandÄ±ÄŸÄ± bir yapÄ±lanmadÄ±r. 

YazÄ±lÄ±mda iÅŸlenecek veriyi yazÄ±lÄ±m adÄ±na Ram'e yerleÅŸtirebilmek iÃ§in biz programcÄ±lar deÄŸiÅŸkenleri kullanÄ±rÄ±z. 

![36](https://github.com/Yasemin-s/C----reniyorum---1/assets/118223063/aab36f51-c993-432c-93d6-006870a5b326)

ğŸ‘‰ ! AyrÄ±ca Ram'in bu veriler Ã¼zerinde iÅŸlem yapabilmesi iÃ§in, veri tÃ¼rÃ¼nÃ¼nde Ram'e belirtilmesi gerekir. Ã–rneÄŸin, "Ahmet" deÄŸeri ile 3 deÄŸeri arasÄ±nda Ã§arpma iÅŸlemi yapÄ±lamaz. Ã‡Ã¼nkÃ¼ veri tÃ¼rleri farklÄ±dÄ±r. 


ğŸ‘‹ 37 - Value Type - Primitive Type - DeÄŸer Tipli DeÄŸiÅŸkenler

DeÄŸiÅŸkenler bilgisayarda yazÄ±lÄ±m adÄ±na Ram'de veri tutan yapÄ±lardÄ±r. Yeri geldi mi bu deÄŸerler Ã¼stÃ¼nde iÅŸlem yapmamÄ±zÄ± saÄŸlayan bu deÄŸerleri elde etmemizi saÄŸlayan yeni Ã¼eretilen deÄŸerleri yazÄ±lÄ±m adÄ±na tekrardan Ram'de depolamamÄ±zÄ± saÄŸlayan yapÄ±lardÄ±r. 

ğŸ‘‰ ! Ä°ÅŸlenecek veriler ram Ã¼zerinde tutulur. Ram bu verilerin deÄŸerlerini tutabilmek iÃ§in alan tahsis eder. Bu alan tahsisi verinin tÃ¼rÃ¼ne gÃ¶re yapÄ±lÄ±r. AyrÄ±ca bir tÃ¼rde tanÄ±mlanmÄ±ÅŸ alana farklÄ± bir tÃ¼rde olan deÄŸer verilemez. Veri tÃ¼rÃ¼ ve ram de o tÃ¼r iÃ§in ayrÄ±lan alan uygun olmalÄ±dÄ±r.

ğŸ‘‰ ! DeÄŸiÅŸkenlerle tÃ¼r bildiriken bool, char, byte, int gibi keywordler kullanÄ±rÄ±z.

ğŸ‘‰ ! â€œStringâ€ de metinsel ifadeleri tutmaya yarayan deÄŸiÅŸken tÃ¼rÃ¼dÃ¼r. Ama deÄŸer tÃ¼rlÃ¼ deÄŸil, referans tÃ¼rlÃ¼dÃ¼r.

YazÄ±lÄ±mda Ã§alÄ±ÅŸÄ±rken deÄŸiÅŸken sayesinde yazÄ±lÄ±mda iÅŸleyeceÄŸiniz veriyi deÄŸiÅŸken vasÄ±tasÄ±yla Ram'e yerleÅŸtirip orada iÅŸleyceksiniz ve iÅŸlerken Ram Ã¼zerinde tutmanÄ±z gerekecek. DolayÄ±sÄ±yla Ram diyor ki vereceÄŸin deÄŸerin tÃ¼rÃ¼nÃ¼ bildirmek zorundasÄ±n. 

ğŸ‘‰ ! Ram'e yerleÅŸtireceÄŸin verinin tÃ¼rÃ¼ neyse onu baÅŸta bildirmen gerekiyor ki ona gÃ¶re Ram'de alan tahsisi yapÄ±lsÄ±n. 

ğŸ‘‰ ! Ram'de hangi tÃ¼rde(int,string, char ...) alan tanÄ±mlanÄ±rsa/tahsis edilirse oraya sadece o tÃ¼re ait bir deÄŸer atamak zorundasÄ±n.

Ram'de veri tutabilmek/depolayabilmek iÃ§in tanÄ±mlanacak olan deÄŸiÅŸkenin tÃ¼rÃ¼/veri tÃ¼rÃ¼ bildirilmelidir.

ğŸ‘‰ ! TÃ¼r elimizdeki veriye gÃ¶re bildirilir. 

Elimizdeki verinin tÃ¼rÃ¼nÃ¼ elimizdeki veri belirliyor. Ram'de hangi deÄŸeri tutacaksan o elindeki veriden tÃ¼rÃ¼ Ã§Ä±kartÄ±yorsun. 

Bir deÄŸiÅŸkenle Ram'de alan tahsisinde bulunulduÄŸunda buna deÄŸer tÃ¼rlÃ¼ deÄŸiÅŸken denir. Yani tuttuÄŸu deÄŸer bir normal deÄŸer olan deÄŸikenlere deÄŸer tÃ¼rlÃ¼ deÄŸiÅŸken denmektedir.  

Yani tuttuÄŸu deÄŸer bir normal deÄŸer olan deÄŸikenlere deÄŸer tÃ¼rlÃ¼ deÄŸiÅŸken denmektedir.  

Ram'de alan tahsisi bulunan bu deÄŸiÅŸken iÃ§inde 3,5,hÃ¼seyin gibi deÄŸerler tuutluyor. DeÄŸiÅŸken iÃ§inde deÄŸer tutar. Ä°ÅŸte tuttuÄŸu deÄŸerin karÅŸÄ±lÄ±ÄŸÄ±nda bir alan tahsisi yapan deÄŸiÅŸkenlere biz deÄŸer tÃ¼rlÃ¼ deÄŸiÅŸkenler diyoruz. Normal bir deÄŸer 3, 5, yaÅŸÄ±n gibi normal deÄŸerler. 

Referans tÃ¼rlÃ¼ deÄŸiÅŸkenler deÄŸer tutmaz, deÄŸerden daha fazlasÄ±nÄ± tutar. 

Ã–rneÄŸin, bir deÄŸiÅŸken var ve benima dÄ±mÄ± tutuyor. Bu deÄŸer tÃ¼rlÃ¼dÃ¼r Ã§Ã¼nkÃ¼ adÄ±m bir deÄŸerdir. Ama bir deÄŸiÅŸken daha var komple beni tutuyor. Ben bir deÄŸer deÄŸilim, deÄŸerler bÃ¼tÃ¼nÃ¼yÃ¼m. AdÄ±m, yaÅŸÄ±m vs var.

Hem adÄ±m hem ben birer veriyiz ama adÄ±m bir deÄŸer tÃ¼rlÃ¼ veriyken ben farklÄ± bir veri tÃ¼rÃ¼yÃ¼m. Biz buna nesne deriz. Ä°ÅŸte nesneleri tutan deÄŸiÅŸkenlere de referans tÃ¼rlÃ¼ deÄŸiÅŸken deeriz.

DeÄŸer tÃ¼rlÃ¼ deÄŸiÅŸkenler sadece bir deÄŸer tutan deÄŸiÅŸkenlerdir. yani adÄ±mÄ±z, soyadÄ±mÄ±z, doÄŸum tarihimmiz vs. gibi deÄŸerlerdir.

AdÄ±nÄ±n, yaÅŸÄ±nÄ±n, doÄŸum tarihinin hepsinin bir deÄŸeri var. YaÅŸ sayÄ±saldÄ±r, adÄ±n metinseldir, adÄ±nÄ±n baÅŸ harfi chardÄ±r. Ä°ÅŸte biz bunun gibi yapÄ±larÄ± tutan deÄŸiÅŸkenlere deÄŸer tÃ¼rlÃ¼ deÄŸiÅŸken deriz.

Primitive Type, en ilkel tÃ¼rdÃ¼r. Primitive, yani tÃ¼retilmemiÅŸ, ham/sade bir veridir. Ã–rneÄŸin byte bir primitive tÃ¼rdÃ¼r. Fakat bytle'lardan meydana gelen decimal tÃ¼rÃ¼ ise primitive tÃ¼r deÄŸildir, bytelardan tÃ¼remiÅŸtir. Ama value type'dÄ±r yani tek bir deÄŸeri/normal bir deÄŸeri tutar. 

HiÃ§bir ÅŸey olmasa bile var olan tÃ¼r Primitive tÃ¼rdÃ¼r. Mesela decimal olabilmesi iÃ§in byte'larÄ±n olmasÄ± gerekir. Byte'lardan meydana gelen decimal normal value type'dÄ±r.

Byte ise tek baÅŸÄ±na bir veridir. HiÃ§bir ÅŸey olmadan tek baÅŸÄ±na var olan bir tÃ¼r oduÄŸu iÃ§in Primtive'dir. AynÄ± zamanda da value type'dÄ±r.

Value type'lar primitive type'larÄ± kapsar.

Ram'de deÄŸiÅŸkenler sayesinde deÄŸer tutabilmekteyiz. DeÄŸiÅŸkenler deÄŸer tÃ¼rlÃ¼yse yani deÄŸer tuttuÄŸumuz deÄŸiÅŸkenlerde bu deÄŸerin karÅŸÄ±lÄ±ÄŸÄ±nÄ± tÃ¼rÃ¼nÃ¼ Ram'e bildirmek zorundayÄ±z. DolayÄ±sÄ±yla burada deÄŸiÅŸkenlerdeki tÃ¼rler Ram'de tutulacak verilerin hangi tÃ¼rde olduÄŸunu bildiren yapÄ±lanmalardÄ±r. Biz bunlarÄ± bildirmek zorundayÄ±z. Ram'de Ã§alÄ±ÅŸÄ±rken hangi tÃ¼rlerle Ã§alÄ±ÅŸtÄ±ÄŸÄ±mÄ±zÄ± bildirmek zorundayÄ±z. 

String metinsel ifadeleri tuttuÄŸumuz deÄŸiÅŸken tÃ¼rÃ¼dÃ¼r. 

SayÄ±sal tÃ¼rlÃ¼ deÄŸiÅŸkenlerin max ve min deÄŸerleri vardÄ±r bu aralÄ±kalrda deÄŸiÅŸkenlerin deÄŸerlerini girebilirsiniz. TutacaÄŸÄ±nÄ±z sayÄ±sal ifadenin boyutuna gÃ¶re deÄŸiÅŸken tÃ¼rÃ¼nÃ¼ belirlemelisiniz. 

Mesela 3 deÄŸerini tutacaksÄ±n. Byte'da tutabilirsin int'de de, ama Ram'de bu kadar alan(..........) tahsis etmek var bir de 3'e yakÄ±n sÄ±nÄ±rlarda olan alanÄ±(...) tahsisi etmek var. Hangisi daha mantÄ±klÄ±/az malliyetli olocaksa o tercih edilmelidir. Yani kendisine yakÄ±n olan alana tam sÄ±nÄ±rÄ±nda girebilen deÄŸiÅŸken tÃ¼rÃ¼nÃ¼ tercih etmemiz en doÄŸrusu olacaktÄ±r. Bunlar optimize kod yazarken/yazÄ±lÄ±mÄ±n daha hÄ±zlÄ±/performanslÄ± Ã§alÄ±ÅŸmasÄ± iÃ§in dikkat ettiÄŸimiz kurallardÄ±r. 

![39](https://github.com/Yasemin-s/C----reniyorum---1/assets/118223063/28e4079e-613b-4a2f-8244-2502aaf960d3)

ğŸ‘‹ 38 - DeÄŸer TÃ¼rlÃ¼ DeÄŸiÅŸkenlerde Primitive KontrolÃ¼ - IsPrimitive

Bir tÃ¼rÃ¼n primitive(ilkel) olup olmadÄ±ÄŸÄ± â€œtypeof(kontrol_edilecek_veri_turu).IsPrimitiveâ€ ile kontrol edilir. Buradaki "." member access yani Ã¼ye eriÅŸim operatorÃ¼dÃ¼r. Bu kontrol sonucunda dÃ¶nen true yada false ile primitive tÃ¼r olup olmadÄ±ÄŸÄ± anlaÅŸÄ±lÄ±r. 
"Decimal" bir primitive tÃ¼r deÄŸildir. Ã‡Ã¼nkÃ¼ arkada "byte"lardan daha doÄŸrusu int tÃ¼rlerden oluÅŸur/meydana gelir. DeÄŸer tÃ¼rlÃ¼dÃ¼r ama "Primitive" deÄŸildir. "int" ve "byte" hem deÄŸer tÃ¼rlÃ¼dÃ¼r hem de "Primitive"dir yani herhangi bir baÅŸka tÃ¼rden meydana getirilmezler. 

ğŸ‘‹ 39 - DeÄŸiÅŸken TÃ¼rleri Nelerdir? DetaylÄ± Ä°nceleyelim

DeÄŸiÅŸkenlerde tanÄ±mlama yaparken bir deÄŸer tutarken Ram'de bunun tÃ¼rÃ¼nÃ¼ bildirmemiz geerekiyordu. Ã–rneÄŸin "Ali" deÄŸerini tutacaksam "string", "1000" deÄŸerini tutacaksam "short" veri tipinde tutarÄ±m.  "1000" deÄŸerini "int"tede tutabilirim ama bÃ¼yÃ¼k bir alanÄ± boÅŸa harcamÄ±ÅŸ olurum.

TutacaÄŸÄ±mÄ±z deÄŸer hangi aralÄ±ÄŸa giriyorsa, en yakÄ±n aralÄ±ÄŸa giren tÃ¼rÃ¼ tercih etmek gerekir. DoÄŸru deÄŸer tÃ¼rÃ¼nÃ¼ tercih etmek uygulamanÄ±n bellek yÃ¶netimi, performansÄ± aÃ§Ä±sÄ±ndan bize avantaj sunar.

"string" metinsel ifadeleri tuttuÄŸumuz deÄŸiÅŸken tÃ¼rÃ¼dÃ¼r. Char'da ise sadece tek bir karakter tutabiliriz. 

![39](https://github.com/user-attachments/assets/9d1c9f6b-4d13-4300-bd7a-ecfd9fa22e2c)

ğŸ‘‹ 40 - C# Temel KurallarÄ±

"{}", scope denir.

![40](https://github.com/user-attachments/assets/181f7cbd-2939-4ade-82a5-9800d108bfd2)

C# Dil Ã–zellikleri;
C# programlama dili nÃ¼yÃ¼k kÃ¼Ã§Ã¼k harf duyarlÄ±lÄ±ÄŸÄ±na sahiptir.
C# programlama dili tip gÃ¼venliÄŸi olan dildir. Elde bulunan veriye uygun rame tÃ¼r bildirimi yapmak gerekiyor. Ä°ÅŸte buna tip gÃ¼venliÄŸi denir. Yani veri tÃ¼rÃ¼ ile ramde ayrÄ±lan alanÄ±n tÃ¼rÃ¼ uygun olmalÄ±dÄ±r.

ğŸ‘‹ 41 - DeÄŸiÅŸken TanÄ±mlama

DeÄŸiÅŸken tanÄ±mlama/oluÅŸturma bir konsept meselesidir. Bir deÄŸiÅŸkeni tanÄ±mlamak istiyorsak Ã¶nce modelini oluÅŸturmalÄ±yÄ±z. Yani prototipi, Ã§nce "degisken_turu degisken_adi;" ÅŸeklinde belirtilir. Burada ";" kod konseptini kapatÄ±r.

Ã–rneÄŸin, "string name;", bu tanÄ±mlamaya gÃ¶re derlendiÄŸinde ramde "string" tÃ¼rÃ¼nde ve "name" adÄ±nda alan ayrÄ±lmÄ±ÅŸtÄ±r.

![41](https://github.com/user-attachments/assets/59cccba1-b493-4ce3-a201-cdc7a81070ec)

ğŸ‘‹ 42 - Ram YapÄ±sÄ± ? 

Ram, bilgisayarÄ±n Ã§alÄ±ÅŸma belleÄŸini temsil eder ve verilerin saklanmasÄ±/eriÅŸilmesi iÃ§in kullanÄ±lÄ±r. Ram temelde stack ve heap olarak iki yapÄ±lanmadan oluÅŸur. Stackte, deÄŸer tÃ¼rlÃ¼ deÄŸiÅŸkenler tutulur. Heapte ise nesneler tutulur. Stackte, deÄŸiÅŸkenlerin tÃ¼rÃ¼, adÄ± ve deÄŸeri tutulur. AyrÄ±ca metot isimlerine (bellek adresleri) de tutulur.
Metotlar Ã§aÄŸrÄ±labilir yapÄ±lardÄ±r ve isimleri ile Ã§aÄŸrÄ±lÄ±rlar. O isme karÅŸÄ±lÄ±k gelen bellek adresi stackte tutulur. 
Ä°leride heap ve stack arasÄ±nda referans tÃ¼rlÃ¼ deÄŸiÅŸkenlerin, referans mantÄ±ÄŸÄ± anlatÄ±lacaktÄ±r.
Referans dediÄŸimiz aslÄ±nda, deÄŸiÅŸkenin kendisidir. DeÄŸiÅŸkenin kendisi stackte tutulur. Stackteki deÄŸiÅŸken, yani referansla heapteki bir nesneyi iÅŸaretlemeye referans tÃ¼rlÃ¼ deÄŸiÅŸkenler denir.
"int yas = 5" tanÄ±mlanmÄ±ÅŸ olsun. Burada "yas"a bazÄ± makalelerde referans denilebileceÄŸini gÃ¶rÃ¼rsÃ¼nÃ¼z. AslÄ±nda "yas" ismi adÄ±/deÄŸiÅŸkeni anlamlarÄ±na gelir. Referans tÃ¼rlÃ¼ deÄŸiÅŸken olduÄŸunu dÃ¼ÅŸÃ¼nmeyin. "yas" ismi 5 deÄŸerini tutuyor, referans ediyor.

![42](https://github.com/user-attachments/assets/75323a54-76fe-4a1a-97e7-ce801e77a404)

ğŸ‘‹ 43 - DeÄŸiÅŸkenler Ram'de NasÄ±l Tutulur?

DeÄŸiÅŸkenler kod olarak yazÄ±lÄ±r yazÄ±lmaz alan tahsis etmezler. Ne zaman ki biz programÄ± Ã§alÄ±ÅŸtÄ±rÄ±rsak(yani compiler tarafÄ±ndan derlendikten sonra runtime olduÄŸu anda) o zaman bellekte alan ayrÄ±lÄ±r.  

int yas;
string adi;
string soyadi; 
kodu Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda, konsept (her bir ";" a kadar olan kÄ±smÄ± ifade eder.) ÅŸeklinde senkron olarak bellekte tutulur. Stack LIFO (Last In First Out) mantÄ±ÄŸÄ±na gÃ¶re Ã§alÄ±ÅŸÄ±r. Yani Son giren ilk Ã§Ä±kar.

ğŸ‘‰ ! LIFO, Ram'in doÄŸrudan Ã§alÄ±ÅŸma ÅŸekli deÄŸil, bellek yÃ¶netimi algoritmalarÄ±nÄ±n Ã¶zelliÄŸidir.

![43](https://github.com/user-attachments/assets/a23a455f-e899-422b-9c26-e9d6bfdc9d0f)

ğŸ‘‹ 44 - DeÄŸiÅŸken TanÄ±mlama KurallarÄ± 

DeÄŸiÅŸken isimleri yazÄ±lÄ±m sÃ¼recinde developer aÃ§Ä±sÄ±ndan bir karÄ±ÅŸÄ±klÄ±ÄŸa mahal vermemek iÃ§in anlamlÄ± olmalÄ±dÄ±r.

1- AnlamlÄ± Ä°simlendirme : DeÄŸiÅŸken isimlendirmede tutacaÄŸÄ±m deÄŸerin anlamÄ±nÄ± ifade eden deÄŸiÅŸken isimlendirmeleri kullanmak yaÄ±zlÄ±m geliÅŸtirme sÃ¼recinde developer iÃ§in faydalÄ± olacaktÄ±r.
 
2- Ã–zel Karakter KullanÄ±lmamalÄ± : DeÄŸiÅŸken isimlendirmelerinde (, . ;) gibi Ã¶zel karakterler kullanÄ±lmaz. "_" ise istisnai bir durumdur.

3- SayÄ± Durumuna GÃ¶re KullanÄ±mlar : DeÄŸiÅŸken isimlendirmede sayÄ± kullanÄ±lmak istenirse deÄŸiÅŸkenin adÄ±na sayÄ± ile baÅŸlayamazsÄ±n ama deÄŸiÅŸken adÄ± iÃ§inde sayÄ± kullanabilirsin. "1sayi" yanlÄ±ÅŸ bir kullanÄ±mken "sayi1"" doÄŸru kullanÄ±mdÄ±r. 

ğŸ‘‰ ! Bir scope iÃ§inde birden fazla aynÄ± isimde deÄŸiÅŸken tanÄ±mlanamaz.

ğŸ‘‹ 45 - Ä°simlendirme KurallarÄ± - Name Convention - Pascal Case - Camel Case - Snake Case 

Pascal Case : Her kelimenin ilk harfi bÃ¼yÃ¼k yazÄ±lÄ±r. KÄ±saltma iki harfli ise her 
iki harfte bÃ¼yÃ¼k yazÄ±lÄ±r. In/Out -> IO, InOutStream -> IOStream ÅŸeklinde yazÄ±lÄ±r.

Camel Case : Ä°lk kelime kÃ¼Ã§Ã¼k diÄŸerleri bÃ¼yÃ¼k yazÄ±lÄ±r. 

![45](https://github.com/user-attachments/assets/4a8181e9-591f-43f2-8b13-bcb8b073c09e)

Snake Case : Ä°lk kelime kÃ¼Ã§Ã¼k diÄŸerleri bÃ¼yÃ¼k yazÄ±lÄ±r.


ğŸ‘‹ 46 - DeÄŸiÅŸken Ä°simlerini "@" OperatorÃ¼yle TanÄ±mlama

Normalde bir deÄŸiÅŸken tanÄ±mlanÄ±rken, deÄŸiÅŸken ismi iÃ§in programatik keyword kullanÄ±lmaz. EÄŸer programatik keyword deÄŸiÅŸken adÄ± olarak kullanÄ±lmak istenirse bunu programa, bu bir keyword deÄŸildir ÅŸeklinde bildirmemiz gerekiyor. Ä°ÅŸte "@" operatorÃ¼ ile keyword kullanÄ±rsak bunun bir programatik keyword olmadÄ±ÄŸÄ±nÄ±, bizim tÄ±pkÄ± "age" "name" ÅŸeklinde kullanabileceÄŸimiz normal bir deÄŸiÅŸken ismi gibi deÄŸiÅŸken adÄ± tanÄ±mladÄ±ÄŸÄ±mÄ±zÄ± sÃ¶ylemiÅŸ/belirtmiÅŸ oluruz. 

string name; //normal bir kullanÄ±mdÄ±r.
string @string; // C#'ta metinsel ifadeleri tanÄ±mlamada kullanÄ±lan bir keyword olan "string" kelimesi normal bir deÄŸiÅŸken ismi gibi "@" kullanÄ±larak belirtilmiÅŸtir. 

ğŸ‘‹ 47 - TanÄ±mlanmÄ±ÅŸ DeÄŸiÅŸkene DeÄŸer Atama

DeÄŸiÅŸkene tanÄ±mlandÄ±ktan sonra deÄŸer atanÄ±r. TanÄ±mlanan deÄŸiÅŸken, belleÄŸin stack kÄ±smÄ±nda, deÄŸer tÃ¼rlÃ¼ deÄŸiÅŸkenlerin (tek 1 deÄŸeri olan, nesne olmayan) tÃ¼rÃ¼, adÄ± ve deÄŸerleri ile tutulur. EÄŸer tanÄ±mlama esnasÄ±nda deÄŸiÅŸkene deÄŸer atamak istersem, "int number = 5;" konsepti kullanÄ±lÄ±r, burada "=" ifadesi atama(assign) opratorÃ¼dÃ¼r. Assign operatorÃ¼, saÄŸdaki deÄŸeri soldakine atar. Bir deÄŸiÅŸkene deÄŸer atanacaksa kesinlikle deÄŸiÅŸken solda, atanacak deÄŸer saÄŸda olmalÄ±dÄ±r.

![47](https://github.com/user-attachments/assets/7ceecc72-d70f-48ae-ab10-9ae549c2ac42)

EÄŸer ki deÄŸiÅŸken ismi assign operatorÃ¼nÃ¼n solunda kalÄ±yorsa o alana deÄŸiÅŸkenin kendisi gelecektir. Tam tersi durum olursa deÄŸiÅŸken ismi saÄŸda olursa bu defa sol tarafa deÄŸiÅŸkenin deÄŸeri gidecektir.

int x;
...
x = 120; 
Bu Ã¶rnekte, "int" tÃ¼rÃ¼nde "x" adÄ±nda ramde alan tahisi edildi. Daha sonra dedik ki bu x deÄŸiÅŸkenini getir.  O alana git ve deÄŸerine 120 ata. EÄŸer "x" assign solundaysa kendisi gelecekti. Kendisi ve deÄŸeri gitmesi farklÄ± ÅŸeyler!

![47-2](https://github.com/user-attachments/assets/c02557ef-0f4c-442e-93ba-fd1f219393f6)
 
ğŸ‘‰ ! Bir deÄŸiÅŸkenin deÄŸerinde en son deÄŸer geÃ§erlidir. Yani bir deÄŸiÅŸkene birden fazla deÄŸer atayabilirim ve atadÄ±ÄŸÄ±m en son deÄŸer geÃ§erlidir. Ã–nceki deÄŸerler ezilecektir/yok sayÄ±lacaktÄ±r/geÃ§ersiz olacaktÄ±r.

int a = 5;
a = 15;
a = 20;
Ã¶rneÄŸe gÃ¶re var olan a deÄŸiÅŸkei Ã¶aÄŸÄ±rÄ±lÄ±p deÄŸeri deÄŸiÅŸir, yeni bir a oluÅŸmaz ve deÄŸiÅŸkenin son deÄŸeri 20 olur.

![47-3](https://github.com/user-attachments/assets/3a8f00f3-be21-4bff-b25d-31be480462d5)

ğŸ‘‰ ! TanÄ±mlanmÄ±ÅŸ olan deÄŸiÅŸken tÃ¼rÃ¼ne gÃ¶re deÄŸer atanmalÄ±dÄ±r.

ğŸ‘‹ 48 - Bir DeÄŸiÅŸkene DeÄŸer Atama KurallarÄ±

DeÄŸiÅŸkenler tÃ¼rÃ¼ne gÃ¶re kategorize edilir. DÃ¶rt kategoride deÄŸer tÃ¼rleri vardÄ±r. Bunlar metinsel, karaktersel, mantÄ±ksal ve sayÄ±sal deÄŸerlerdir.

Metinsel deÄŸerler, string keywordu ile tutulur. Metinsel ifadeler "" iÃ§ine yazÄ±lÄ±r. Bir sayÄ±sal ifade ""(Ã§ift tÄ±rnak) iÃ§inde yazÄ±larak tutulursa yazÄ±lÄ±m aÃ§Ä±sÄ±ndan bu ifade metinsel ifade olarak kabul edilir ve tutulan sayÄ±sal deÄŸer Ã¼zerinde herhagi bir matematiksel iÅŸlem yapÄ±lamaz. "string sayi = 4;" gibi. 

Karakter deÄŸerleri ''(tek tÄ±rnak) iÃ§inde tutulur ve sadece tek bir karakteri tutar. (o ; 3) gibi.

MantÄ±ksal deÄŸerler bool tÃ¼rÃ¼nde tutulur. True(1) yada false (0) olarak belirtilir. "bool medeniDurum = false;" gibi.

SayÄ±sal deÄŸerler direkt olarak tutulur. 1000 sayÄ±sÄ±nÄ± tutmak istediÄŸimiz dÃ¼ÅŸÃ¼nelim. Peki bu hangi tÃ¼rde bir sayÄ±sal ifade olacaktÄ±r. SayÄ±sal ifadelerde bir deÄŸer default olarak "int" kabul edilir. Bir sayÄ±sal tÃ¼r deÄŸer aralÄ±ÄŸÄ±na girmeyen deÄŸeri tutamaz. Compiler hata verir. "int yas = 1000000000" hatalÄ± bir kullanÄ±mdÄ±r.
 
OndalÄ±klÄ± SayÄ±lar : TÃ¼m ondalÄ±klÄ± sayÄ±lar tam sayÄ±larÄ± karÅŸÄ±layabilir. OndalÄ±klÄ± sayÄ±lar, "float", "double" ve "decimal" tÃ¼rÃ¼nde tutulabilir. Ama kÃ¼sÃ¼ratlÄ± sayÄ±lar olmaya baÅŸlayÄ±nca sÄ±kÄ±ntÄ± olmaya baÅŸlÄ±yor.

Float : Float tÃ¼rÃ¼nde kÃ¼sÃ¼ratlÄ± bir deÄŸer tutarken ilgili deÄŸeri sonuna f yada F getirilir. "3.14f" yada "3.14F" gibi.

Double : Ä°lgiil deÄŸerin sonuna d yada D getirilir.  "3.14d" yada "3.14D" yada "3.14" gibi.

Decimal : Ä°lgili deÄŸiÅŸkenin sonuna m yada M getirilir. "3.14m" yada "3.14M" gibi.

ğŸ‘‹ 49 - (_a,_b) = (a,b) Tuple TÃ¼rÃ¼yle DeÄŸer Atama

Tek bir syntax ile birden fazla deÄŸiÅŸkeni tanÄ±mlamamÄ±zÄ± saÄŸlayan bir nesnedir. 
(int a, int b, type c, type d) z; burada tuple deÄŸiÅŸken tanÄ±mlamasÄ± yapÄ±lmÄ±ÅŸtÄ±r. z iÃ§inde , int type vs. olmak Ã¼zere birden fazla farklÄ± yada benzer tÃ¼rde deÄŸiÅŸken tanÄ±mÄ± yapÄ±lÄ±r. Yani tuple birden fazla deÄŸiÅŸken tutar ve bu deÄŸiÅŸkenlerinde deÄŸerleri olacak. Bunlasr yine stackte tutulacak. 

ğŸ‘‰ ! Tuple, deÄŸiÅŸkene deÄŸer atama tÃ¼rÃ¼dÃ¼r.

ÅÃ¶yle ki, C# dilinde tuple'lar kullanÄ±larak birden fazla deÄŸeri tek bir deÄŸiÅŸken iÃ§inde gruplayabiliriz. (int a, int b) c = (3,5); Bu durumda, c adÄ±nda bir tuple tanÄ±mlanÄ±r ve iÃ§inde ik tam sayÄ± deÄŸeri saklar. Bu tuple, stack belleÄŸinde oluÅŸturulur. a ve b isimli iki tamsayÄ± deÄŸiÅŸkeni gibi davranÄ±r ve tuple iÃ§inde 3 ve 5 deÄŸerleri atanÄ±r. C#'ta tuple'lar genellikle kÃ¼Ã§Ã¼k veri yapÄ±larÄ±nÄ± temsil etmek iÃ§in kullanÄ±lÄ±r ve bu nedenle genellikle stack belleÄŸinde saklanÄ±rlar. Ancak, bÃ¼yÃ¼k tuple'lar veya tuple'lar bir koleksiyonun iÃ§inde kullanÄ±ldÄ±ÄŸÄ±nda heap belleÄŸinde saklanabilirler. Tuple'Ä±n boyutu ve iÃ§eriÄŸi ramde saklanacak davranÄ±ÅŸÄ± etkileyebilir. 

Tuple nesnesi, iÃ§ine bir veya dah afazla deÄŸiÅŸken tanÄ±mlayabildiÄŸimiz tek bir tanÄ±mlÄ±k nesnedir. (int a, string b) c = (5,  "ali"); burada atamalar da sÄ±rayla oluyor. a'ya be b'ye eriÅŸim saÄŸlamak iÃ§in c. ile eriÅŸiyoruz. 

![49](https://github.com/user-attachments/assets/f992b5f4-cb8b-49eb-8a78-f9c85478356c)

Tuple, C# 7.0 programlama dilinde bir veri yapÄ±sÄ±dÄ±r. Tuple, farklÄ± veri tiplerinden oluÅŸan, sabit uzunlukta ve deÄŸerleri deÄŸiÅŸtirilemeyen(immutable) bir koleksiyondur.

ğŸ‘‰ ! Tuple bir nesnedir. C#'ta her ÅŸey bir nesnedir ve Tuple da System.Object sÄ±nÄ±fÄ±ndan tÃ¼remiÅŸtir.

DeÄŸerleri deÄŸiÅŸtirilemezdir. (immutable)
FarklÄ± veri tipleri iÃ§erebilir.
Eleman sayÄ±sÄ± oluÅŸturulduÄŸunda sabittir.
Elemanlara Item1, Item2... ÅŸeklinde eriÅŸilir.

Tuple<int, string> person = new Tuple<int, string>(25,"ali );
int age = person.Item1;

ValueType adÄ±nda struct kullanÄ±lmaya baÅŸlayÄ±nca;
(int Age, string Name) person = (25, "ali");
Console.WriteLine($"Age: {person.Age}");

Maximum 8 Ã¶ÄŸe iÃ§erebilir. Daha fazlasÄ± iÃ§in iÃ§ iÃ§e Tuple'lar kullanÄ±labilir.
Orijinal Tuple'larda Ã¶ÄŸelere anlamlÄ± isimler verilmez. Item1, Item2 ...

Tuple, bir referans tipidir. Yani heap belleÄŸinde saklanÄ±r. Bu, bÃ¼yÃ¼k miktarlarda kullanÄ±ldÄ±ÄŸÄ±nda performans aÃ§Ä±sÄ±ndan dezavantaj olabilir.

âœ¨ Tuple'Ä±n Nesne OlmasÄ± : Tuple bir nesnedir, ancak sadece System.Object'te tÃ¼rediÄŸi iÃ§in deÄŸil. C#'ta her ÅŸey(deÄŸer tipleri dahil) en temel seviyede Object sÄ±nÄ±fÄ±ndan tÃ¼rer. Tuple bir nesnedir Ã§Ã¼nkÃ¼, 
Referans tiplidir.
Heap'te depolanÄ±r.
Garbage collection'a tabidir.
 
âœ¨ Koleksiyon ve Nesne FarkÄ± : 
Nesne, veri ve davranÄ±ÅŸalrÄ±(metotlarÄ±) kapsÃ¼lleyen bir yapÄ±dÄ±r.
Koleksiyon, birden fazla nesneyi veya deÄŸeri iÃ§eren bir veri yapÄ±sÄ±dÄ±r. 
Yani bir koleksiyon aynÄ± zmanada bir nesnedir. Tuple, hem bir nesne hem de bir koleksiyon olarak dÃ¼ÅŸÃ¼nÃ¼lebilir.
 
âœ¨ Tuple'Ä±n Heap'te TutulmasÄ± :
Tuple heap'te tutulur. Ã‡Ã¼nkÃ¼, 
 * Referans Tipi - Tuple bir referans tipidir. C#'ta tÃ¼m referans tipelri heap'te depolanÄ±r.
 * DeÄŸiÅŸken Boyutu - Tuple'lar farklÄ± boyutlarda olabilir ve farklÄ± tiplerde veriler iÃ§erebilir. Heap, bu tÃ¼r deÄŸiÅŸken boyutlu ve karmaÅŸÄ±k yapÄ±lar iÃ§in uygundur.
 * YaÅŸam SÃ¼resi - Heap'teki nesneler, referanslarÄ± olduÄŸu sÃ¼rece yaÅŸarlar ve garbage collector tarafÄ±ndan yÃ¶netilirler. Bu, Tuple'larÄ±n metot Ã§aÄŸrÄ±larÄ± arasÄ±nda bil evarlÄ±kalrÄ±nÄ± sÃ¼rdÃ¼rmelerine olanak tanÄ±r.
 * Esneklik - Heap dinamik bellek tahsisi saÄŸlar, bu da Tuple gibi yapÄ±larÄ±n runtime'da oluÅŸturulmasÄ±na ve yÃ¶netilmesine izin verir.

âœ¨ Stack'te TutulmamasÄ±nÄ±n Nedenleri:
Stack, genellikle sabit boyutlu ve kÄ±sa Ã¶mÃ¼rlÃ¼ veriler iÃ§in kullanÄ±lÄ±r.
Stack'in boyutu sÄ±nÄ±rlÄ±dÄ±r ve bÃ¼yÃ¼k veya karmaÅŸÄ±k nesneler iÃ§i uygun deÄŸildir.
Stack'teki veriler metot Ã§aÄŸrÄ±alrÄ± arasÄ±nda otomatik olarak temizlenir, bu da Tuple gibi daha uzun Ã¶mÃ¼rlÃ¼ olabilen yapÄ±ar iÃ§in uygun deÄŸildir.

ğŸ‘‰ ! C# 7.0 ile birlikte gelen valueTuple, Tuple'Ä±n bir deÄŸer tipi versiyonudur ve stack'te tutulur. 

ğŸ‘‹ 50 - Literal DÃ¼zenlemeler C# 7.0

Kompleks sayÄ±sal ifadelerin "_" ile dÃ¼zenlenmesini saÄŸlayan bir Ã¶zelliktir. 
int sayi = 1_000_000_000 gibi

ğŸ‘‹ 51 - DeÄŸiÅŸken TÃ¼rÃ¼ne Uygun Default DeÄŸer Atama

TÃ¼m deÄŸiÅŸkenlerin bir default deÄŸeri vardÄ±r. Default deÄŸeri nerde, nasÄ±l, ne ÅŸekilde atandÄ±ÄŸÄ±nÄ± daha sonra class yapÄ±lanmalarÄ±nda gÃ¶receÄŸiz. 
Ä°leride oop dediÄŸimiz yaklaÅŸÅŸÄ±mÄ± gÃ¶rdÃ¼ÄŸÃ¼mÃ¼zde class iÃ§inde tanÄ±mlanan deÄŸiÅŸkenlerin default deÄŸerleri otomatik olarak atanÄ±r.

ğŸ‘‰ ! Null deÄŸersiz demektir ve deÄŸersizle boÅŸ arasÄ±nda fark vardÄ±r. BoÅŸ, boÅŸtur ama yine de bir karakterdir(boÅŸluk/space tuÅŸunun oluÅŸturduÄŸu karakter). Null, deÄŸeri yok demektir.

ğŸ‘‰ ! string = null
     char = "\0"
     sayÄ±sal ifade = 0
     bool = false
     
ğŸ‘‰ ! Normalde bu varsayÄ±lan deÄŸerler, class iÃ§inde otomatik atanmaktadÄ±r. Ama main iÃ§inde atanmaz. Bir tÃ¼rÃ¼n default deÄŸerini "default(ogrenilmek_istenen_tur)" olarak gÃ¶rebilirsiniz.

ğŸ‘‰ ! Main iÃ§inde oluÅŸturulan deÄŸiÅŸkenlerin ilk deÄŸerlerini manuel olarak atamaya  Ã¶zen gÃ¶stermeliyiz.

ğŸ‘‹ 52 - Default Literals C# 7.1

"default(ogrenilmek_istenen_tur)" bu kullanÄ±m yerine, deÄŸiÅŸkeninde belli olduÄŸu "default" kullanÄ±mÄ± yeterlidir. 
string ad = default; gibi bir kullanÄ±m. 

ğŸ‘‹ 53 - TanÄ±mlanmÄ±ÅŸ Bir DeÄŸiÅŸkenin DeÄŸerini Okuma

Bir deÄŸiÅŸkenin deÄŸerinin okunabilmesi iÃ§in, Ã¶nce deÄŸiÅŸkenin tanÄ±mlanmÄ±ÅŸ olmasÄ± daha sonra atamasÄ±nÄ±n yapÄ±lmasÄ± gerekiyor. DeÄŸiÅŸken deÄŸerini elde edebilmek iÃ§in deÄŸiÅŸkenin isminden faydalanÄ±lÄ±r. 

ğŸ‘‰ ! Bir deÄŸiÅŸken adÄ±, assign operatÃ¶rÃ¼nÃ¼n saÄŸÄ±nda yada metotlarÄ±n parametrelerinde Ã§aÄŸÄ±rÄ±lÄ±yorsa, ilgili deÄŸiÅŸkenin deÄŸeri gÃ¶nderilir.

Mesela "Console.WriteLine(x);" veya "int y = x;" burada, iÅŸte bu durumda x yazÄ±lan yerlere x'in deÄŸeri gÃ¶nderilecektir. x'in kendisi Ã§aÄŸrÄ±lsaydÄ±(bellek adresi gider) x, deÄŸer almaya gidecekti. Amma burda x'in deÄŸeri Ã§aÄŸÄ±rÄ±lÄ±yor. 

ğŸ‘‰ ! Console.WriteLine() ekrana Ã§Ä±ktÄ± veren, ekrana biÅŸey yazmamÄ±zÄ± saÄŸlayan bir komuttur.

ğŸ‘‰ ! Console bir sÄ±nÄ±ftÄ±r/class'tÄ±r. Bu sÄ±nÄ±fÄ±n Ã¼zerinden direkt bir member'a eriÅŸilebildiÄŸi iÃ§in static bir yapÄ±lanmadÄ±r. Bu static member'Ä±n bir metot olduÄŸunu buna eriÅŸirkende static yapÄ±lanmadan faydalanÄ±p eriÅŸebildiÄŸimizi .'nÄ±n modifier access operatÃ¶rÃ¼ olduÄŸunu metotlarÄ±n parametre alabildiÄŸini ileride gÃ¶receÄŸiz.

ğŸ‘‹ 54 - TanÄ±mlanmÄ±ÅŸ Bir DeÄŸiÅŸkenin DeÄŸerini Okuma - Kritik 1 

int a = 5;
int b = 10;
int c = b;
int d = a;
b = a;
c = b;

![52-1](https://github.com/user-attachments/assets/04c798e6-97e0-45cf-9ee8-d90bfdd04f4f)

![54-2](https://github.com/user-attachments/assets/0d4ab57d-f03f-419c-8e94-48e653131b3d)

ğŸ‘‹ 55 - TanÄ±mlanmÄ±ÅŸ Bir DeÄŸiÅŸkenin DeÄŸerini Okuma - Kritik 2

int a = 5;
a = a;

![55](https://github.com/user-attachments/assets/3efb199e-5428-40f0-8ea9-f3ff002cd3ee)

ğŸ‘‹ 56 - DeÄŸeri Olmayan DeÄŸiÅŸkenler

Bir deÄŸiÅŸkeni main metodu iÃ§inde oluÅŸturduÄŸunuzda bellekte alan tahhsis edilir ve bu deÄŸeri olmayan deÄŸiÅŸkenlerle neler yapÄ±lÄ±r?
Classlarda deÄŸiÅŸken tanÄ±mlanÄ±p atanmazsa otomatik atanma default deÄŸerlerle yapÄ±lÄ±yordu. 
Mainde deÄŸeri olmayan bir deÄŸiÅŸkeni bir yerde Ã§aÄŸÄ±ramam(deÄŸerini yazdÄ±ramam).
BaÅŸka bir deÄŸiÅŸkene, deÄŸeri olmayan bir deÄŸiÅŸkeni atayamam.
Bir metot iÃ§inde tanÄ±mlanan deÄŸiÅŸkenlerin ilk deÄŸerlerini manuel olarak vermeyi alÄ±ÅŸkalÄ±k haline getirin. Ã‡Ã¼nkÃ¼ programÄ±n rahatÃ§a iÅŸlenebilmesi ve kullanÄ±labilmesi iÃ§inidr. 

ğŸ‘‹ 57 - DeÄŸiÅŸken DavranÄ±ÅŸlarÄ± Genel BakÄ±ÅŸ - Ref Ä°Ã§in FarkÄ±ndalÄ±k 

int a = 5 olsun, stackte tutulur. Ramde veri tÃ¼rÃ¼ne gÃ¶re alan tahsis ediliyor ve bulunduÄŸu alana gÃ¶re veri tutuluyor. Ramde verilerimiz olucak ve biz yazÄ±lÄ±mcÄ± olarak rame doÄŸrudan pointer ile doÄŸrudan eriÅŸebiliyoruz, ancak diÄŸer deÄŸiÅŸkenlerle doÄŸrudan bellek adresine eriÅŸemiyoruz. Ram bellekten deÄŸiÅŸkeni alÄ±rÄ±z/iÅŸleriz/kullanÄ±rÄ±z iÅŸte bu sÃ¼reÃ§te davranÄ±ÅŸsal olarak deÄŸiÅŸkenler isimleri Ã¼zerinden hareket ediyor.

Bir deÄŸiÅŸkenin ismini assign operatÃ¶rÃ¼nÃ¼n solunda Ã§aÄŸÄ±rÄ±rsak farklÄ± davranÄ±ÅŸ, saÄŸÄ±nda Ã§aÄŸÄ±rÄ±rsak farklÄ± davranÄ±ÅŸ sergiliyor. Solundaysa, deÄŸiÅŸkenin kendisini yani bellek adresini bellekteki o kÄ±smÄ± o alanÄ± getirir. DolayÄ±sÄ±yla o kÄ±sma bir atama iÅŸlemi yapabilirsin. SaÄŸÄ±ndaysa, deÄŸiÅŸkenin deÄŸerini getirir. 

ğŸ‘‰ ! Sol tarafta: Bir deÄŸiÅŸkenin ismi, bellek adresini iÅŸaret eder. Bu, deÄŸiÅŸkenin hangi bellek bÃ¶lgesinde saklandÄ±ÄŸÄ±nÄ± belirtir ve bu bÃ¶lgeye yeni bir deÄŸer atama iÅŸlemi yapÄ±labilir.

ğŸ‘‰ ! SaÄŸ tarafta: DeÄŸiÅŸkenin ismi, bellekte saklanan deÄŸeri getirir. Bu, deÄŸiÅŸkenin iÃ§indeki gerÃ§ek veriyi kullanmak iÃ§in gereklidir.

X(a), bu metotta a'ya deÄŸiÅŸkenin deÄŸeri gelecek. Parametre, fonksiyonun parantezinin iÃ§ini ifade eder.

DeÄŸiÅŸken davranÄ±ÅŸÄ±nda deÄŸiÅŸkenin kendi gitmesi ve deÄŸerinin gÃ¶nderilmesi farklÄ± ÅŸeylerdir. 

ğŸ‘‹ 58 - DeÄŸiÅŸkenlerin Faaliyet AlanlarÄ± - Scope KavramÄ± 

Scope, faaliyet alanÄ±, kapsamdÄ±r. DeÄŸiÅŸken ve fonksiyonlarÄ±n eriÅŸilebilirlik sÄ±nÄ±rlarÄ±nÄ± belirleyen alandÄ±r. TanÄ±mlamalarda ve algoritmik Ã§alÄ±ÅŸmalarda karÄ±ÅŸÄ±klÄ±ÄŸÄ± Ã¶nleyen bir sÄ±nÄ±r Ã§izer. C#'ta "{}" ile ifade edilir. 
Scope iÃ§inde tanÄ±mladÄ±ÄŸÄ±m deÄŸiÅŸkene o scope iÃ§inde her yerde eriÅŸebilirim. AyrÄ±ca bir scope iÃ§inde tanÄ±mlanan baÅŸka scopelar olursa yani scopelar iÃ§ iÃ§eyse yine eriÅŸim olur. Ama bir scope dÄ±ÅŸÄ±nda farklÄ± bir scope tanÄ±mlanÄ±rsa/farklÄ± iki scope iÃ§in eriÅŸim olmaz.

![58](https://github.com/user-attachments/assets/4f0971be-13d8-454d-bdff-0544f4922640)

Bir scope iÃ§inde aynÄ± isimde birden fazla deÄŸiÅŸken olmaz ama farklÄ± scopelarda aynÄ± isimde deÄŸiÅŸkenler olabilir. Bu scopelar farklÄ± threadlerde iÅŸlenir yani iki scope'nda iÅŸleri baÅŸkadÄ±r.

![58-2](https://github.com/user-attachments/assets/d1d8aa6e-8b8b-45d4-a771-0b08bbbb2e0f)

![58-3](https://github.com/user-attachments/assets/f992dcb5-ccc0-40e6-b63b-8d2ef794fb03)

ğŸ‘‹ 59 - Custom Scope OluÅŸturmak

Kendimizde scope oluÅŸturabiliyoruz. Kodun iÃ§inde metodu faaliyet alanlarÄ±na bÃ¶lebiliyoruz. Ä°stediÄŸiniz kadar Custom Scope oluÅŸturabilirsiniz. {{{{{}}}}} 

ğŸ‘‹ 60 - DeÄŸiÅŸmezler/Sabitler/Const

YazÄ±lÄ±mda verileri doÄŸru bir ÅŸekilde iÅŸleyip sonuÃ§ elde etmeye Ã§alÄ±ÅŸÄ±yorduk. Ä°ÅŸleyeceÄŸimiz veri her zaman deÄŸiÅŸiklik gÃ¶sterebilir ama bazen sabit deÄŸerlerle de Ã§alÄ±ÅŸmamÄ±z gerekebilir. Yani sabit deÄŸiÅŸkenlerin deÄŸerlerinin deÄŸiÅŸmemesi gerekir. SÃ¼reÃ§te var olan deÄŸiÅŸken deÄŸiÅŸtirilmez, deÄŸiÅŸtirilmeye Ã§alÄ±ÅŸÄ±lÄ±rsa compiler hatta verir. 

Const,
Constanttan gelir.
TanÄ±mlama aÅŸamsÄ±ndayken deÄŸerini atamak zorundasÄ±n.
DeÄŸiÅŸmeyendir fakat  istenildiÄŸi kadar okuanbilir/deÄŸerleri elde edilebilir.
Prototip olarak deÄŸiÅŸkenlere Ã§ok benzer fakat davranÄ±ÅŸsal olarak deÄŸeri bir daha deÄŸiÅŸtirilemez. 
Ã–zÃ¼nde static yapÄ±lanmadÄ±r.
Bir const tanÄ±mlandÄ±ÄŸÄ±nda STACK'te ilgili tÃ¼rde alan tahsis edilecektir ve ilk atanan deÄŸer dÄ±ÅŸÄ±nda bir daha deÄŸer kabul etmeyecektir.

âœ¨ Static 
Uygulama bazlÄ± veri depolayabildiÄŸimiz bellekte bir alandÄ±r. Static dedÄŸiÅŸkenlerde uygulamanÄ±n her yerinden eriÅŸim saÄŸlayabilirsin. Evrenseldir yani. Static'i bilmek iÃ§in diÄŸer alanlarÄ± da bilmek gerekiyor. Stack, heap ve static gibi bellek alanlarÄ±na sahiptir. Åimdi scopelarda tanÄ±mladÄ±ÄŸÄ±mÄ±z yerden eriÅŸilebilir demiÅŸtir ama staticte Ã¶yle deÄŸil.

âœ¨ Static Ä°le Const ArasÄ±ndaki Fark Nedir ? 
Static deÄŸiÅŸkenler adÄ± Ã¼stÃ¼nde deÄŸiÅŸkendir, deÄŸerleri deÄŸiÅŸtirilebilir ama consttlarÄ±n deÄŸeri deÄŸiÅŸtirilemez. Constlar statictir ama sabit olan statictir. Her yerde eriÅŸirsin ve deÄŸerini deÄŸiÅŸtiremezsin. YapÄ±sal olarak static bellek alanÄ±nda tutulur. 

âœ¨Readonly
Sadece okunabilir deÄŸiÅŸkenler tanÄ±mlamaktadÄ±r. Atanan deÄŸer bir daha deÄŸiÅŸtirilemez. 

âœ¨ Const ve Readonly ArasÄ±ndaki Fark Nedir ?
Consttan farkÄ± sadece tanÄ±mlandÄ±ÄŸÄ± yerde deÄŸil, ayrÄ±ca constructor iÃ§inde de deÄŸeri atanabilir. Dependency injection deseninde Ã§ok sÄ±k tercih edilir. Yani tanÄ±mlama anÄ±nda yada constructorÄ±nda atama yapabilirsin. Ama consstta Ã¶yle deÄŸil sadece tanÄ±malama aÅŸamasÄ±nda atama yapabilirsin ve readonly static deÄŸildir. 

Const tanÄ±mlamada "const degisken_turu degisken_adi = deÄŸeri;" ÅŸeklinde tanÄ±mlama yapÄ±lÄ±r. 
AslÄ±nda normal bir ÅŸekilde de deÄŸiÅŸkeni bir kere tanÄ±mlayÄ±p kullanabiliriz ama insan hali yanlÄ±ÅŸlÄ±kla deÄŸerini sonradan deÄŸiÅŸtirebiliriz iÅŸte bunun Ã¶nÃ¼ne geÃ§ebilmek iÃ§in deÄŸiÅŸmezleri const keywordÃ¼ ile iÅŸaretleriz. 

ğŸ‘‹ 61 - Global DeÄŸiÅŸkenler

KonumlandÄ±rÄ±ldÄ±ÄŸÄ± yere gÃ¶re bir deÄŸiÅŸken ya global olur yada local olur. YapÄ±sÄ±, iÅŸleyiÅŸi yada sorumluluÄŸu deÄŸiÅŸmiyor sadece adÄ± deÄŸiÅŸiyor.
Bir deÄŸiÅŸken class scope'u iÃ§inde tanÄ±mlanÄ±yorsa buna global denir. Metotlar iÃ§inde tanÄ±mlamaya ise local denir. Scope'lara gÃ¶re dÃ¼ÅŸÃ¼nerek local/global diyebilirsin.

ğŸ‘‹ 62 - DeÄŸiÅŸken TanÄ±mlama VaryasyonlarÄ± 

Ä°ki tane deÄŸiÅŸken tanÄ±mlama varyasyonu vardÄ±r. Ä°lki deÄŸiÅŸkeni tanÄ±mlayÄ±p ister o an istersen daha sonra deÄŸer atayabilirsin. 
int a = 5;
int b = 14;

Ä°kinci varyasyon, aynÄ± tÃ¼rden birden fazla deÄŸiÅŸken oluÅŸturulacaksa eÄŸer bu deÄŸiÅŸkenlerin tek imzada tanÄ±mlanabilmesidir. 
int a = 5, b = 14; ÅŸeklinde tanÄ±mlama yapÄ±labilir. Ä°stersek deÄŸer attanmadan sadece tanÄ±mlamada yapÄ±labilir. 

int a, b; gibi. Burda dikkat edilmesi gereken husus aynÄ± tÃ¼rden olmalarÄ± gerekmektedir.

ğŸ‘‹ 63 - DeÄŸiÅŸkenler ArasÄ± DeÄŸer Atama DurumlarÄ± - Deep Copy

DeÄŸiÅŸkenler arasÄ±nda deÄŸer atama durumlarÄ±nda veri aÃ§Ä±sÄ±ndan davranÄ±ÅŸÄ±n nasÄ±l olduÄŸunu inceleyelim.
DeÄŸiÅŸkenler arasÄ±nda deÄŸer atanÄ±rken, deÄŸerler birbirine atanÄ±rken, bir deÄŸiÅŸkendeki deÄŸer bir baÅŸka deÄŸiÅŸkene atanÄ±rken, burada verisel aÃ§Ä±dan nasÄ±l bir davranÄ±ÅŸ sergilenir onu inceleyeceÄŸiz.
DeÄŸiÅŸkenler arasÄ± deÄŸer atanÄ±rken verisel aÃ§Ä±dan iki davranÄ±ÅŸ sÃ¶z konusudur. Deep copy(klonlayÄ±p, tekrar edip yeniden oluÅŸturma) ile yapÄ±labilir yada shallow copy(yÃ¼zeysel kopyalama) dediÄŸimiz atama yapÄ±labilir.

âœ¨ Deep Copy

![63-1](https://github.com/user-attachments/assets/fb23a521-8479-4dee-8621-e3f64c18ef3a)

![63-2](https://github.com/user-attachments/assets/4992e69a-b019-4f6c-8e46-134b28ef88ad)

Var olan veriyi derinden kopyalÄ±yor, klonluyor. Eldeki veri Ã§oÄŸalÄ±yor. Eldeki veri birken iki oluyor. 

ğŸ‘‰ ! DeÄŸer tÃ¼rlÃ¼ deÄŸiÅŸkenler birbirine atanÄ±rken default olarak deep copy geÃ§erlidir. Yani veri otomatik olarak Ã¼retilir. int decimal bool vs. gibi tÃ¼rlerde birbirine atama durumlarÄ± olursa deep copy ile olur. 

Åimdi klonlama durumunun gerÃ§ek olup olmadÄ±ÄŸÄ±nÄ± nasÄ±l inceleyeceÄŸiz.
int a = 5;
int b = a;
a = a * 5;
Console.WriteLine(a);
Console.WriteLine(b); 
a'da yaptÄ±ÄŸÄ±n deÄŸiÅŸiklik b'ye yansÄ±mayacaksa deep copydir.

ğŸ‘‹ 64 - DeÄŸiÅŸkenler ArasÄ± DeÄŸer Atama DurumlarÄ± - Shallow Copy

DavranÄ±ÅŸ olarak biraz daa geliÅŸmiÅŸ bir yapÄ±lanmadÄ±r. AslÄ±nda referansÄ± kopyalÄ±yoruz. DeÄŸiÅŸkenler arasÄ± deÄŸer atamalarÄ±nda deÄŸeri tÃ¼retmek/Ã§oÄŸaltmak/klonlamak yerine var olanÄ± birden fazla referansla iÅŸaretlemeye dayalÄ± kopyalama yÃ¶ntemidir. 
Stackteki deÄŸiÅŸkenler heap'teki deÄŸeri iÅŸaretliyorsa, bu yÃ¼zeysel kopyalamadÄ±r.

![64-4](https://github.com/user-attachments/assets/04313dec-d607-45e9-a285-1dc472b1bf17)

ğŸ‘‰ ! Default olarak shallow copy, referans tÃ¼rlÃ¼ deÄŸiÅŸkenlerde geÃ§erlidir. 

Bellekte birden fazla referansÄ±n tek bir veriyi iÅŸaret etmesi durumunda deÄŸiÅŸkenler/referanslar kendi aralarÄ±nda shallow copydir. 
SonuÃ§ta ilgili deÄŸer bir deÄŸiÅŸikliÄŸe uÄŸradÄ±ÄŸÄ±nda, deÄŸeri iÅŸaretleyen tÃ¼m referanslara bu deÄŸiÅŸiklik yansÄ±yacaktÄ±r. 

Normalde deÄŸer tÃ¼rlÃ¼ deÄŸiÅŸkenler default olarak deep copy edilirler. Ä°leride "ref keywordÃ¼" incelenirken, deÄŸer tÃ¼rlÃ¼ deÄŸiÅŸkenlerde shallow copy nasÄ±l yapÄ±lÄ±r bunu inceleyeceÄŸiz.
Shallow copy, oop derslerinde ele alacaÄŸÄ±mmÄ±z Ã¼zere nesne ve referans arasÄ±ndaki iliÅŸkide varsayÄ±lan davranÄ±ÅŸ olarak kabul edilir. Oop'de nesneler iÃ§in varsayÄ±lan olan shallow copyin haricinde deep copy nasÄ±l yapÄ±lÄ±r bunu inceleyeceÄŸiz. 

ğŸ‘‰ ! Deep copy deÄŸer tÃ¼rlÃ¼ deÄŸiÅŸkenlerde varsayÄ±landÄ±r. Shallow copy referans tÃ¼rlÃ¼ deÄŸiÅŸkenlerde varsayÄ±landÄ±r. 

ğŸ‘‹ 65 - Object TÃ¼rÃ¼

Object Nedir ?
Åimdi ben bir deÄŸer tutacaÄŸÄ±m ve bu deÄŸer tÃ¼rÃ¼ne uygun deÄŸiÅŸkende tutulmalÄ±dÄ±r. Ã–rneÄŸin 3 int de, ahmet stringte, a da charda tutulmalÄ±dÄ±r ama ben bunlarÄ±n hepsini "object" tÃ¼rÃ¼nde de tutabilirim.

ğŸ‘‰ ! Object, tÃ¼m tÃ¼rleri (deÄŸer,referans) karÅŸÄ±layabilen bir tÃ¼rdÃ¼r. Peki neden karÅŸÄ±layabilyor ?
BÃ¼tÃ¼n tÃ¼rler varsayÄ±lan olarak objectten tÃ¼rerler. 

![65-1](https://github.com/user-attachments/assets/e6aafdfc-ae74-4e93-a037-52f2373189a6)

GÃ¶rsele gÃ¶re string de char da objectte tutulabilir. Object tÃ¼rlerin ademidir, ilkidir, hiÃ§bir tÃ¼r yokken object vardÄ±. Bu yÃ¼zden tÃ¼m tÃ¼rleri karÅŸÄ±layabilir. Object, kÄ±saca verilen deÄŸeri karÅŸÄ±layabilen tÃ¼rdÃ¼r. 

ğŸ‘‰ ! Object, referans tÃ¼rlÃ¼ bir deÄŸiÅŸkendir. Fakar deÄŸer tÃ¼rlÃ¼ deÄŸerleri de karÅŸÄ±layabilir. 

Objectte bir deÄŸer atandÄ±ÄŸÄ±nda nasÄ±l davranÄ±ÅŸ sergiler ?
Object deÄŸiÅŸkenler, ilgili verileri ramde object tÃ¼rde tutarlar. Fakat verinin Ã¶z tÃ¼rÃ¼nÃ¼ de iÃ§inde bozmadan saklarlar. Yani object iÃ§indeki veri, kendi Ã¶z tÃ¼rÃ¼nde tutulur. 

![65-2](https://github.com/user-attachments/assets/e5065024-79f8-4bb2-af1c-5c0d3c460dbd)

Åarap Ã¶rneÄŸi, dÄ±ÅŸarÄ±dan object gÃ¶rÃ¼nÃ¼yor ama iÃ§inde string. Bu durumda, object iÃ§indeki veriyi kendi tÃ¼rÃ¼nde elde edebiliriz anlamÄ±na gelir. Ä°ÅŸte objectteki bu Ã¶zelliÄŸe boxing denir. 

ğŸ‘‰ ! Boxing, veriyi object iÃ§ine koymaktÄ±r, kutulamaktÄ±r. O veriyi object iÃ§inden kendi tÃ¼rÃ¼nde Ã§Ä±kartmaya da unboxing denir.


ğŸ‘‹ 66 - Object TÃ¼rÃ¼ - Boxing

Object tÃ¼rdeki bir deÄŸiÅŸkene herhangi bir tÃ¼rdeki bir deÄŸeri gÃ¶ndermektedir. 

int yas = 23;
object  _yas = 23;

ilk tanÄ±mlamada stackte int tÃ¼rÃ¼nde tutulacaktÄ±r. Ama ikinci deÄŸiÅŸken tanÄ±mlamda object tÃ¼rÃ¼ iÃ§inde int tutuluyor.

Boxing iÅŸlemi sonucunda ilgili deÄŸer object tÃ¼rÃ¼ iÃ§inde kendi tÃ¼rÃ¼yle tutulur. Fakat "_yas" deÄŸiÅŸkeni artÄ±k 23 deÄŸerini bizlere object tÃ¼rde getirecektir. 

ğŸ‘‰ ! Dikkat ederseniz object tÃ¼rde elde edilen deÄŸer Ã¼zerinde tÃ¼rÃ¼ne Ã¶zgÃ¼ iÅŸlemler gerÃ§eklÅŸtiremezsiniz. Ã–rneÄŸin, sayÄ±sal bir deÄŸer varsa o deÄŸer object olarak geleceÄŸinden dolayÄ± matematiksel iÅŸlem yapamazsÄ±nÄ±z.

ğŸ‘‰ ! Object bir deÄŸiÅŸkenin iÃ§indeki deÄŸer Ã¼zerinde tÃ¼re Ã¶zgÃ¼ iÅŸlemler yapabilmek iÃ§in o objectin iÃ§indeki deÄŸeri, kendi tÃ¼rÃ¼nde elde etmemiz gerekir. Ä°ÅŸte bu iÅŸleme unboxing denir.

ğŸ‘‰ ! Herhangi bir deÄŸer object tÃ¼re assign ediliyorsa eÄŸer, bu iÅŸlem kesinlikle boxingdir.

ğŸ‘‹ 67 - Cast OperatÃ¶rÃ¼

Boxing edilmiÅŸ bir veriyi (objecte dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmÃ¼ÅŸ, objecte set edilmiÅŸ, assign edilmiÅŸ bir veri) kendi tÃ¼rÃ¼nde elde etmemizi saÄŸlayan bir operatÃ¶rÃ¼dÃ¼r. 

TÃ¼r dÃ¶nÃ¼ÅŸÃ¼mlerinde bilinÃ§li tÃ¼r dÃ¶nÃ¼ÅŸÃ¼mÃ¼ konusunda cast operatÃ¶rÃ¼ kullanÄ±lacaktÄ±r. AyrÄ±ca kalÄ±tsal durumlarda dad karÅŸÄ±mÄ±za Ã§Ä±kacaktÄ±r. 

Cas operatÃ¶rÃ¼ "()" dir. Cast operatÃ¶rÃ¼ parantezdir ve yanÄ±na object deÄŸeri alÄ±r.

Cast operatÃ¶rÃ¼,, object olan deÄŸiÅŸkenin solunda o objectin hangi tÃ¼re unboxing etmek istiyorsak parantez iÃ§inde hedef tÃ¼rÃ¼ bildirerek kullanÄ±rÄ±z. Ã–rneÄŸin,
int yas = 5;
object _yas = a; // boxing
(int)_yas; // unboxing - cast operatÃ¶rÃ¼ _yas deÄŸiÅŸkeni/objesi iÃ§indeki deÄŸeri bana int olarak vermektedir.

ğŸ‘‹ 68.1 - Object - Unboxing

Unboxing, boxing edilmiÅŸ bir deÄŸeri kendi tÃ¼rÃ¼nde objectten Ã§Ä±kartmaktÄ±r.

objectt _yas = 28;
_yas * 5; yaptÄ±ÄŸÄ±mÄ±zda hata verir. Ã‡Ã¼nkÃ¼ biri int diÄŸeri objecttir. Bu iÅŸlemi gerÃ§ekleÅŸtirebilmem iÃ§in object'i int'e Ã§ervirmem gerekiyor. Burada (int)_yas; ÅŸeklinde cast edersek/Ã§Ä±karÄ±rsak/unboxing yaparsak artÄ±k elimizde int tÃ¼rÃ¼ne ait bir veri olmuÅŸ olacak ve deÄŸeri int deÄŸiÅŸken tÃ¼rÃ¼ne atayarak matematiksel iÅŸlemelri gerÃ§ekleÅŸtirebiliriz. int __yas = (int)_yas;

âœ¨ Åimdi 28 deÄŸerini int'e atayabilirken neden object'e atadÄ±k ?

Bazen sÄ±nÄ±flarda/metotlarda yada yapmanÄ±z gereken tasarÄ±mlarda object kullanmanÄ±z gerekebilir. Ã‡Ã¼nkÃ¼ gelecek verinin tÃ¼rÃ¼nÃ¼ bilemeyebilirsiniz. Ä°ÅŸte oradaki tÃ¼rÃ¼ bilemediÄŸimiz iÃ§in object ile karÅŸÄ±layÄ±p iÃ§eride yapacaÄŸÄ±n iÅŸlemler iÃ§in onu tÃ¼rÃ¼ne ayÄ±klamak gerekir. 

ğŸ‘‰ ! Unboxing iÅŸlemi esnasÄ±nda boxing edilmiÅŸ tÃ¼r ne ise onu bildirmemiz gerekir. 

ğŸ‘‹ 68.2 - Object - Unboxing

EÄŸer int tÃ¼rÃ¼nde veriyi string olarak cast etmeye Ã§alÄ±ÅŸÄ±rsan program patlar.

int _yas = 5;
string yas = (string)_yas; kod semantik aÃ§Ä±dan doÄŸru olduÄŸu iÃ§in hata vermez gibi gÃ¶rÃ¼nÃ¼yor ama compiler edilip runtime kÄ±smÄ±na gelince boxing unbozing iÅŸlemi yapÄ±ldÄ±ÄŸÄ±nda orada kod patlar.

ğŸ‘‹ 69 - C# Var KeywordÃ¼ Nedir - Ne Ä°ÅŸe Yara ? 

"var" bir deÄŸiÅŸken deÄŸil, bir keyworddÃ¼r ve belli iÅŸlemi yapan keyworddÃ¼r.

EÄŸer, tutacaÄŸÄ±n deÄŸere gÃ¶re deÄŸiÅŸkenin tÃ¼rÃ¼nÃ¼ compiler'a belirletmek istiyorsanÄ±z var kwyeordÃ¼ kullanabilirsiniz. 

"var" keywordÃ¼, kendisine atanan deÄŸerin tÃ¼rÃ¼ne bÃ¼rÃ¼nÃ¼r.

bool medeniHal = true;
var medeniHal = true; ÅŸeklinde tanÄ±mlamada yapÄ±labilir. Burada true bool olduÄŸu iÃ§in var bool tÃ¼rÃ¼ne bÃ¼rÃ¼necektir.

ğŸ‘‰ ! var keywordÃ¼, compiler tarafÄ±ndan deÄŸerin tÃ¼rÃ¼ne gÃ¶re otomatik bÃ¼rÃ¼ndÃ¼rÃ¼len bir keyworddÃ¼r. Fakat bir tÃ¼r deÄŸildir. Genellikle, yazacaÄŸÄ±mÄ±z deÄŸiÅŸkenlerin tÃ¼rlerini yazmaktan Ã¼ÅŸendiÄŸimiz iÃ§in kullanÄ±rÄ±z. Halbuki, esasen farklÄ± diller arasÄ±nda desteklenmeyen tÃ¼rlerdeki verileri karÅŸÄ±layabilmek iÃ§in oluÅŸturulmuÅŸ, ortak bir keyyworddÃ¼r. 

ğŸ‘‰ !  var, diller arasÄ±ndaki entegrasyonda kullanÄ±lÄ±yor.

var keywordÃ¼ ile tanÄ±mlanan deÄŸiÅŸkenin deÄŸeri tanÄ±mlama aÅŸamasÄ±nda verilmeli ki tÃ¼rÃ¼ belirlenip direkt ona dÃ¶nÃ¼ÅŸebilsin ve o tÃ¼rde davranÄ±ÅŸ sergilesin.

ğŸ‘‰ ! var keywordÃ¼yle tanÄ±mlanan deÄŸiÅŸkene ilk deÄŸer verildikten sonra o deÄŸerin tÃ¼rÃ¼ne bÃ¼rÃ¼neceÄŸi iÃ§in sonraki durumlarda deÄŸeri farklÄ± tÃ¼rde verilmez. 

âœ¨ Var - Object ArasÄ±ndaki Fark 

var x = 5;
object y = 15;
var stackte int tÃ¼rÃ¼nde tutulur. Birinde unboxing boxing iÅŸlemi olur diÄŸerinde olmaz. Yani var bir keyword iken object bir tÃ¼rdÃ¼r. "var" atanan deÄŸerin tÃ¼rÃ¼ne bÃ¼rÃ¼nÃ¼rken, "object" atanan deÄŸeri boxing ederek objecte dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r. 

âœ¨ Var Bellek YapÄ±sÄ± 

var anahtar kelimesi, bellek yapÄ±sÄ± aÃ§Ä±sÄ±ndan Ã¶zel bir yapÄ± oluÅŸturmaz; sadece deÄŸiÅŸkenin tÃ¼rÃ¼nÃ¼ belirlemenin daha kÄ±sa bir yoludur. Derleyici, tÃ¼rÃ¼ belirlediÄŸinde, bu tÃ¼rÃ¼n bellek yapÄ±sÄ± normalde nasÄ±l ise aynÄ± ÅŸekilde bellek yÃ¶netimi yapÄ±lÄ±r.

ğŸ‘‹ 70 - C# Dynamic Keyword Ne Ä°ÅŸe Yarar Nedir ? 

var a = 5;
var'a Ã§ok benzer, var'Ä±n runtime'daki versiyonudur.
var'da compiler sÃ¼recindeyken dÃ¶nÃ¼ÅŸÃ¼m olur.
dynamic b = 14;
dynamic compiler sÃ¼recindeyken hala dynamictir. Ne zamanki program Ã§alÄ±ÅŸtÄ±rÄ±lÄ±p runtime olursa o zaman ilgili deÄŸerin tÃ¼rÃ¼ne bÃ¼rÃ¼nÃ¼r. b int olur yani. Dynamic olan deÄŸiÅŸkenin tÃ¼rÃ¼ belli olmadan deÄŸiÅŸkeni Ã§aÄŸÄ±rÄ±rsan herhangi bir ÅŸekilde metottaki bir veriye eriÅŸemezsin. Ã‡Ã¼nkÃ¼ gelecek olan memberlarÄ± bilmiyorsun/gÃ¶remiyorsun.

var da tanÄ±mlama aÅŸamasÄ±nda ilgili deÄŸerin tÃ¼rÃ¼ne bÃ¼rÃ¼ndÃ¼ÄŸÃ¼nden dolayÄ±, sonradan deÄŸeri deÄŸiÅŸtirilmek istenirse tÃ¼re uygun olarak deÄŸer verilmelidir. Dynamic'te ise, runtime da tÃ¼r belirlenir ama kararlÄ± davranmaz. Yani dynamic'te Ã¶nce string sonra int double vs. olabilir.

âœ¨ Dynamic Nerelerde Tercih Edilir ?

TÃ¼rÃ¼nÃ¼ bilmediÄŸimiz uzaktan veri geldiÄŸinde kullanÄ±lÄ±r, var ile karÅŸÄ±layamayÄ±z Ã§Ã¼nkÃ¼.
