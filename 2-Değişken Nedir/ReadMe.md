ğŸ‘‹ 31 - DeÄŸiÅŸken Nedir? Bir ProgramcÄ±nÄ±n DeÄŸiÅŸkene Neden Ä°htiyacÄ± Olur?

Bir programcÄ±nÄ±n amacÄ± eldeki verilerle oluÅŸturulan yazÄ±lÄ±mlarÄ±n doÄŸru bir ÅŸekilde iÅŸlenip sonuÃ§lar elde edebilmesidir.

Hangi yazÄ±lÄ±m olursa olsun amaÃ§, burada bir veriyi doÄŸru bir ÅŸekilde iÅŸleyebilmek doÄŸru bir ÅŸekilde iÅŸlerken bu veriyle ilgili operasyonlarÄ± gerÃ§ekleÅŸtirebilmektir.

DeÄŸiÅŸken, bu yazÄ±lÄ±m sÃ¼recinde bir amaca hizmet eden bir yapÄ±lanmadÄ±r.
YazÄ±lÄ±malar veriyi doÄŸru bir ÅŸekilde iÅŸleyip Ã§Ä±ktÄ± veren yapÄ±lanmalardÄ±r.
Burada merkeze veriyi alÄ±rsak bu veri yazÄ±lÄ±mÄ±n neresindedir? Ä°ÅŸte iÅŸlenecek bir veri var ve bunu yazÄ±lÄ±mda bir yerde tutmam lazÄ±m. 

ğŸ‘‰ ! Bilgisayarda ram dediÄŸimiz bir kÄ±sÄ±m var. Ram'e geÃ§ici bellek yada Ã¶nbellek deriz. O anki Ã§alÄ±ÅŸtÄ±ÄŸÄ±mÄ±z verileri Ram'e koyuyoruz. DolayÄ±sÄ±yla iÅŸlem yapma esnasÄ±nda iÅŸlem yapÄ±lan/iÅŸlenen veri Ram'de tutulur.

Ram kendi iÃ§inde bÃ¶lÃ¼mlere ayrÄ±lmÄ±ÅŸ bir yapÄ±lamaya sahiptir.
YazÄ±lÄ±mda biz ÅŸunu yapÄ±yoruz. Diyoruz ki benim elimde 5 diye bir deÄŸer var.
Bu 5 deÄŸerini benim Ram'e koyup oradan daha sonra yazÄ±lÄ±mda iÅŸleyebilmem
gerekiyor. YazÄ±lÄ±m Ram'deki bu 5 deÄŸerini alabiliyor kendi bÃ¼nyesinde iÅŸleyebiliyor yada Ã¼rettiÄŸi 5'i yine Ram'e koyabiliyor.

ğŸ‘‰ ! Yani yazÄ±lÄ±m veri tutmaz. YazÄ±lÄ±m veriyi Ram'den alÄ±r Ram'e yerleÅŸtirir.

ğŸ‘‰ ! YazÄ±lÄ±mda veri tutulamz Ram'de tutulur.

YazÄ±lÄ±m da yapÄ±lacak iÅŸlemlerin en kÃ¼Ã§Ã¼k en merkezi noktasÄ± olan veriyi biz Ram'de tutarÄ±z. 

Bir yazÄ±lÄ±mda iÅŸlenecek veriyi Ram'de tutabilmek iÃ§in deÄŸiÅŸkenler kullanÄ±lÄ±r.

DeÄŸiÅŸken dediÄŸimiz, yazÄ±lÄ±m adÄ±na Ram'e veri koymamÄ±zÄ± ve ihtiyaÃ§ doÄŸrultusunda o Ram'deki veriyi elde etmemizi saÄŸlayan yapÄ±lardÄ±r.

Yani sen bir veriyi iÅŸleyebilmek iÃ§in o veriyi yazÄ±lÄ±ma koyabilmen iÃ§in onu gidip yazÄ±lÄ±m adÄ±na Ram'e koyman lazÄ±m. Ä°ÅŸte o yazÄ±lÄ±m adÄ±na veriyi Ram'e koyan yapÄ±lanmaya deÄŸiÅŸken denir. 

DeÄŸiÅŸken, adÄ± Ã¼stÃ¼nde deÄŸiÅŸen/deÄŸiÅŸken yapÄ±lardÄ±r.

Bir programcÄ± verisini tutabilmek iÃ§in deÄŸiÅŸkene ihtiyaÃ§ duyar. 

ğŸ‘‰ ! Ä°ÅŸlenecek veriler veritabanÄ±nda tutulur doÄŸru ama siz yine bunu iÅŸleme esnasÄ±nda bu verileri Ram'e almanÄ±z gerekecektir. 

ğŸ‘‰ ! Ä°ÅŸlem boyutundayken veritabanÄ±nda bir veriyi iÅŸleyemezsin. Ram'deki veriyi iÅŸleyebilirsin. 

ğŸ‘‰ ! Biz iÅŸ yapÄ±yorsak %100 Ram'de Ã§alÄ±ÅŸmalÄ±yÄ±z. 

Bir yazÄ±lÄ±mÄ±n Ram'de Ã§alÄ±ÅŸabilmesi, Ram'e deÄŸer koyabilmesi, Ram'deki bir deÄŸeri elde edebilmesi iÃ§in deÄŸiÅŸkenleri kullancaÄŸÄ±z. 

DeÄŸiÅŸken bir programcÄ±nÄ±n yazÄ±lÄ±mda iÅŸleyeceÄŸi veriyi Ram'de o program adÄ±na tutabilmesi iÃ§in kullandÄ±ÄŸÄ± bir yapÄ±lanmadÄ±r. 

YazÄ±lÄ±mda iÅŸlenecek veriyi yazÄ±lÄ±m adÄ±na Ram'e yerleÅŸtirebilmek iÃ§in biz programcÄ±lar deÄŸiÅŸkenleri kullanÄ±rÄ±z. 

![36](https://github.com/Yasemin-s/C----reniyorum---1/assets/118223063/aab36f51-c993-432c-93d6-006870a5b326)

ğŸ‘‰ ! AyrÄ±ca Ram'in bu veriler Ã¼zerinde iÅŸlem yapabilmesi iÃ§in, veri tÃ¼rÃ¼nÃ¼nde Ram'e belirtilmesi gerekir. Ã–rneÄŸin, "Ahmet" deÄŸeri ile 3 deÄŸeri arasÄ±nda Ã§arpma iÅŸlemi yapÄ±lamaz. Ã‡Ã¼nkÃ¼ veri tÃ¼rleri farklÄ±dÄ±r. 


ğŸ‘‹ 37 - Value Type - Primitive Type - DeÄŸer Tipli DeÄŸiÅŸkenler

DeÄŸiÅŸkenler bilgisayarda yazÄ±lÄ±m adÄ±na Ram'de veri tutan yapÄ±lardÄ±r. Yeri geldi mi bu deÄŸerler Ã¼stÃ¼nde iÅŸlem yapmamÄ±zÄ± saÄŸlayan bu deÄŸerleri elde etmemizi saÄŸlayan yeni Ã¼eretilen deÄŸerleri yazÄ±lÄ±m adÄ±na tekrardan Ram'de depolamamÄ±zÄ± saÄŸlayan yapÄ±lardÄ±r. 

ğŸ‘‰ ! Ä°ÅŸlenecek veriler ram Ã¼zerinde tutulur. Ram bu verilerin deÄŸerlerini tutabilmek iÃ§in alan tahsis eder. Bu alan tahsisi verinin tÃ¼rÃ¼ne gÃ¶re yapÄ±lÄ±r. AyrÄ±ca bir tÃ¼rde tanÄ±mlanmÄ±ÅŸ alana farklÄ± bir tÃ¼rde olan deÄŸer verilemez. Veri tÃ¼rÃ¼ ve ram de o tÃ¼r iÃ§in ayrÄ±lan alan uygun olmalÄ±dÄ±r.

ğŸ‘‰ ! DeÄŸiÅŸkenlerle tÃ¼r bildiriken bool, char, byte, int gibi keywordler kullanÄ±rÄ±z.

ğŸ‘‰ ! â€œStringâ€ de metinsel ifadeleri tutmaya yarayan deÄŸiÅŸken tÃ¼rÃ¼dÃ¼r. Ama deÄŸer tÃ¼rlÃ¼ deÄŸil, referans tÃ¼rlÃ¼dÃ¼r.

YazÄ±lÄ±mda Ã§alÄ±ÅŸÄ±rken deÄŸiÅŸken sayesinde yazÄ±lÄ±mda iÅŸleyeceÄŸiniz veriyi deÄŸiÅŸken vasÄ±tasÄ±yla Ram'e yerleÅŸtirip orada iÅŸleyceksiniz ve iÅŸlerken Ram Ã¼zerinde tutmanÄ±z gerekecek. DolayÄ±sÄ±yla Ram diyor ki vereceÄŸin deÄŸerin tÃ¼rÃ¼nÃ¼ bildirmek zorundasÄ±n. 

ğŸ‘‰ ! Ram'e yerleÅŸtireceÄŸin verinin tÃ¼rÃ¼ neyse onu baÅŸta bildirmen gerekiyor ki ona gÃ¶re Ram'de alan tahsisi yapÄ±lsÄ±n. 

ğŸ‘‰ ! Ram'de hangi tÃ¼rde(int,string, char ...) alan tanÄ±mlanÄ±rsa/tahsis edilirse oraya sadece o tÃ¼re ait bir deÄŸer atamak zorundasÄ±n.

Ram'de veri tutabilmek/depolayabilmek iÃ§in tanÄ±mlanacak olan deÄŸiÅŸkenin tÃ¼rÃ¼/veri tÃ¼rÃ¼ bildirilmelidir.

ğŸ‘‰ ! TÃ¼r elimizdeki veriye gÃ¶re bildirilir. 

Elimizdeki verinin tÃ¼rÃ¼nÃ¼ elimizdeki veri belirliyor. Ram'de hangi deÄŸeri tutacaksan o elindeki veriden tÃ¼rÃ¼ Ã§Ä±kartÄ±yorsun. 

Bir deÄŸiÅŸkenle Ram'de alan tahsisinde bulunulduÄŸunda buna deÄŸer tÃ¼rlÃ¼ deÄŸiÅŸken denir. Yani tuttuÄŸu deÄŸer bir normal deÄŸer olan deÄŸikenlere deÄŸer tÃ¼rlÃ¼ deÄŸiÅŸken denmektedir.  

Yani tuttuÄŸu deÄŸer bir normal deÄŸer olan deÄŸikenlere deÄŸer tÃ¼rlÃ¼ deÄŸiÅŸken denmektedir.  

Ram'de alan tahsisi bulunan bu deÄŸiÅŸken iÃ§inde 3,5,hÃ¼seyin gibi deÄŸerler tuutluyor. DeÄŸiÅŸken iÃ§inde deÄŸer tutar. Ä°ÅŸte tuttuÄŸu deÄŸerin karÅŸÄ±lÄ±ÄŸÄ±nda bir alan tahsisi yapan deÄŸiÅŸkenlere biz deÄŸer tÃ¼rlÃ¼ deÄŸiÅŸkenler diyoruz. Normal bir deÄŸer 3, 5, yaÅŸÄ±n gibi normal deÄŸerler. 

Referans tÃ¼rlÃ¼ deÄŸiÅŸkenler deÄŸer tutmaz, deÄŸerden daha fazlasÄ±nÄ± tutar. 

Ã–rneÄŸin, bir deÄŸiÅŸken var ve benima dÄ±mÄ± tutuyor. Bu deÄŸer tÃ¼rlÃ¼dÃ¼r Ã§Ã¼nkÃ¼ adÄ±m bir deÄŸerdir. Ama bir deÄŸiÅŸken daha var komple beni tutuyor. Ben bir deÄŸer deÄŸilim, deÄŸerler bÃ¼tÃ¼nÃ¼yÃ¼m. AdÄ±m, yaÅŸÄ±m vs var.

Hem adÄ±m hem ben birer veriyiz ama adÄ±m bir deÄŸer tÃ¼rlÃ¼ veriyken ben farklÄ± bir veri tÃ¼rÃ¼yÃ¼m. Biz buna nesne deriz. Ä°ÅŸte nesneleri tutan deÄŸiÅŸkenlere de referans tÃ¼rlÃ¼ deÄŸiÅŸken deeriz.

DeÄŸer tÃ¼rlÃ¼ deÄŸiÅŸkenler sadece bir deÄŸer tutan deÄŸiÅŸkenlerdir. yani adÄ±mÄ±z, soyadÄ±mÄ±z, doÄŸum tarihimmiz vs. gibi deÄŸerlerdir.

AdÄ±nÄ±n, yaÅŸÄ±nÄ±n, doÄŸum tarihinin hepsinin bir deÄŸeri var. YaÅŸ sayÄ±saldÄ±r, adÄ±n metinseldir, adÄ±nÄ±n baÅŸ harfi chardÄ±r. Ä°ÅŸte biz bunun gibi yapÄ±larÄ± tutan deÄŸiÅŸkenlere deÄŸer tÃ¼rlÃ¼ deÄŸiÅŸken deriz.

Primitive Type, en ilkel tÃ¼rdÃ¼r. Primitive, yani tÃ¼retilmemiÅŸ, ham/sade bir veridir. Ã–rneÄŸin byte bir primitive tÃ¼rdÃ¼r. Fakat bytle'lardan meydana gelen decimal tÃ¼rÃ¼ ise primitive tÃ¼r deÄŸildir, bytelardan tÃ¼remiÅŸtir. Ama value type'dÄ±r yani tek bir deÄŸeri/normal bir deÄŸeri tutar. 

HiÃ§bir ÅŸey olmasa bile var olan tÃ¼r Primitive tÃ¼rdÃ¼r. Mesela decimal olabilmesi iÃ§in byte'larÄ±n olmasÄ± gerekir. Byte'lardan meydana gelen decimal normal value type'dÄ±r.

Byte ise tek baÅŸÄ±na bir veridir. HiÃ§bir ÅŸey olmadan tek baÅŸÄ±na var olan bir tÃ¼r oduÄŸu iÃ§in Primtive'dir. AynÄ± zamanda da value type'dÄ±r.

Value type'lar primitive type'larÄ± kapsar.

Ram'de deÄŸiÅŸkenler sayesinde deÄŸer tutabilmekteyiz. DeÄŸiÅŸkenler deÄŸer tÃ¼rlÃ¼yse yani deÄŸer tuttuÄŸumuz deÄŸiÅŸkenlerde bu deÄŸerin karÅŸÄ±lÄ±ÄŸÄ±nÄ± tÃ¼rÃ¼nÃ¼ Ram'e bildirmek zorundayÄ±z. DolayÄ±sÄ±yla burada deÄŸiÅŸkenlerdeki tÃ¼rler Ram'de tutulacak verilerin hangi tÃ¼rde olduÄŸunu bildiren yapÄ±lanmalardÄ±r. Biz bunlarÄ± bildirmek zorundayÄ±z. Ram'de Ã§alÄ±ÅŸÄ±rken hangi tÃ¼rlerle Ã§alÄ±ÅŸtÄ±ÄŸÄ±mÄ±zÄ± bildirmek zorundayÄ±z. 

String metinsel ifadeleri tuttuÄŸumuz deÄŸiÅŸken tÃ¼rÃ¼dÃ¼r. 

SayÄ±sal tÃ¼rlÃ¼ deÄŸiÅŸkenlerin max ve min deÄŸerleri vardÄ±r bu aralÄ±kalrda deÄŸiÅŸkenlerin deÄŸerlerini girebilirsiniz. TutacaÄŸÄ±nÄ±z sayÄ±sal ifadenin boyutuna gÃ¶re deÄŸiÅŸken tÃ¼rÃ¼nÃ¼ belirlemelisiniz. 

Mesela 3 deÄŸerini tutacaksÄ±n. Byte'da tutabilirsin int'de de, ama Ram'de bu kadar alan(..........) tahsis etmek var bir de 3'e yakÄ±n sÄ±nÄ±rlarda olan alanÄ±(...) tahsisi etmek var. Hangisi daha mantÄ±klÄ±/az malliyetli olocaksa o tercih edilmelidir. Yani kendisine yakÄ±n olan alana tam sÄ±nÄ±rÄ±nda girebilen deÄŸiÅŸken tÃ¼rÃ¼nÃ¼ tercih etmemiz en doÄŸrusu olacaktÄ±r. Bunlar optimize kod yazarken/yazÄ±lÄ±mÄ±n daha hÄ±zlÄ±/performanslÄ± Ã§alÄ±ÅŸmasÄ± iÃ§in dikkat ettiÄŸimiz kurallardÄ±r. 

![39](https://github.com/Yasemin-s/C----reniyorum---1/assets/118223063/28e4079e-613b-4a2f-8244-2502aaf960d3)

ğŸ‘‹ 38 - DeÄŸer TÃ¼rlÃ¼ DeÄŸiÅŸkenlerde Primitive KontrolÃ¼ - IsPrimitive

Bir tÃ¼rÃ¼n primitive(ilkel) olup olmadÄ±ÄŸÄ± â€œtypeof(kontrol_edilecek_veri_turu).IsPrimitiveâ€ ile kontrol edilir. Buradaki "." member access yani Ã¼ye eriÅŸim operatorÃ¼dÃ¼r. Bu kontrol sonucunda dÃ¶nen true yada false ile primitive tÃ¼r olup olmadÄ±ÄŸÄ± anlaÅŸÄ±lÄ±r. 
"Decimal" bir primitive tÃ¼r deÄŸildir. Ã‡Ã¼nkÃ¼ arkada "byte"lardan daha doÄŸrusu int tÃ¼rlerden oluÅŸur/meydana gelir. DeÄŸer tÃ¼rlÃ¼dÃ¼r ama "Primitive" deÄŸildir. "int" ve "byte" hem deÄŸer tÃ¼rlÃ¼dÃ¼r hem de "Primitive"dir yani herhangi bir baÅŸka tÃ¼rden meydana getirilmezler. 

ğŸ‘‹ 39 - DeÄŸiÅŸken TÃ¼rleri Nelerdir? DetaylÄ± Ä°nceleyelim

DeÄŸiÅŸkenlerde tanÄ±mlama yaparken bir deÄŸer tutarken Ram'de bunun tÃ¼rÃ¼nÃ¼ bildirmemiz geerekiyordu. Ã–rneÄŸin "Ali" deÄŸerini tutacaksam "string", "1000" deÄŸerini tutacaksam "short" veri tipinde tutarÄ±m.  "1000" deÄŸerini "int"tede tutabilirim ama bÃ¼yÃ¼k bir alanÄ± boÅŸa harcamÄ±ÅŸ olurum.

TutacaÄŸÄ±mÄ±z deÄŸer hangi aralÄ±ÄŸa giriyorsa, en yakÄ±n aralÄ±ÄŸa giren tÃ¼rÃ¼ tercih etmek gerekir. DoÄŸru deÄŸer tÃ¼rÃ¼nÃ¼ tercih etmek uygulamanÄ±n bellek yÃ¶netimi, performansÄ± aÃ§Ä±sÄ±ndan bize avantaj sunar.

"string" metinsel ifadeleri tuttuÄŸumuz deÄŸiÅŸken tÃ¼rÃ¼dÃ¼r. Char'da ise sadece tek bir karakter tutabiliriz. 

![39](https://github.com/user-attachments/assets/9d1c9f6b-4d13-4300-bd7a-ecfd9fa22e2c)

ğŸ‘‹ 40 - C# Temel KurallarÄ±

"{}", scope denir.

![40](https://github.com/user-attachments/assets/181f7cbd-2939-4ade-82a5-9800d108bfd2)

C# Dil Ã–zellikleri;
C# programlama dili nÃ¼yÃ¼k kÃ¼Ã§Ã¼k harf duyarlÄ±lÄ±ÄŸÄ±na sahiptir.
C# programlama dili tip gÃ¼venliÄŸi olan dildir. Elde bulunan veriye uygun rame tÃ¼r bildirimi yapmak gerekiyor. Ä°ÅŸte buna tip gÃ¼venliÄŸi denir. Yani veri tÃ¼rÃ¼ ile ramde ayrÄ±lan alanÄ±n tÃ¼rÃ¼ uygun olmalÄ±dÄ±r.

ğŸ‘‹ 41 - DeÄŸiÅŸken TanÄ±mlama

DeÄŸiÅŸken tanÄ±mlama/oluÅŸturma bir konsept meselesidir. Bir deÄŸiÅŸkeni tanÄ±mlamak istiyorsak Ã¶nce modelini oluÅŸturmalÄ±yÄ±z. Yani prototipi, Ã§nce "degisken_turu degisken_adi;" ÅŸeklinde belirtilir. Burada ";" kod konseptini kapatÄ±r.

Ã–rneÄŸin, "string name;", bu tanÄ±mlamaya gÃ¶re derlendiÄŸinde ramde "string" tÃ¼rÃ¼nde ve "name" adÄ±nda alan ayrÄ±lmÄ±ÅŸtÄ±r.

![41](https://github.com/user-attachments/assets/59cccba1-b493-4ce3-a201-cdc7a81070ec)

ğŸ‘‹ 42 - Ram YapÄ±sÄ± ? 

Ram, bilgisayarÄ±n Ã§alÄ±ÅŸma belleÄŸini temsil eder ve verilerin saklanmasÄ±/eriÅŸilmesi iÃ§in kullanÄ±lÄ±r. Ram temelde stack ve heap olarak iki yapÄ±lanmadan oluÅŸur. Stackte, deÄŸer tÃ¼rlÃ¼ deÄŸiÅŸkenler tutulur. Heapte ise nesneler tutulur. Stackte, deÄŸiÅŸkenlerin tÃ¼rÃ¼, adÄ± ve deÄŸeri tutulur. AyrÄ±ca metot isimlerine (bellek adresleri) de tutulur.
Metotlar Ã§aÄŸrÄ±labilir yapÄ±lardÄ±r ve isimleri ile Ã§aÄŸrÄ±lÄ±rlar. O isme karÅŸÄ±lÄ±k gelen bellek adresi stackte tutulur. 
Ä°leride heap ve stack arasÄ±nda referans tÃ¼rlÃ¼ deÄŸiÅŸkenlerin, referans mantÄ±ÄŸÄ± anlatÄ±lacaktÄ±r.
Referans dediÄŸimiz aslÄ±nda, deÄŸiÅŸkenin kendisidir. DeÄŸiÅŸkenin kendisi stackte tutulur. Stackteki deÄŸiÅŸken, yani referansla heapteki bir nesneyi iÅŸaretlemeye referans tÃ¼rlÃ¼ deÄŸiÅŸkenler denir.
"int yas = 5" tanÄ±mlanmÄ±ÅŸ olsun. Burada "yas"a bazÄ± makalelerde referans denilebileceÄŸini gÃ¶rÃ¼rsÃ¼nÃ¼z. AslÄ±nda "yas" ismi adÄ±/deÄŸiÅŸkeni anlamlarÄ±na gelir. Referans tÃ¼rlÃ¼ deÄŸiÅŸken olduÄŸunu dÃ¼ÅŸÃ¼nmeyin. "yas" ismi 5 deÄŸerini tutuyor, referans ediyor.

![42](https://github.com/user-attachments/assets/75323a54-76fe-4a1a-97e7-ce801e77a404)

ğŸ‘‹ 43 - DeÄŸiÅŸkenler Ram'de NasÄ±l Tutulur?

DeÄŸiÅŸkenler kod olarak yazÄ±lÄ±r yazÄ±lmaz alan tahsis etmezler. Ne zaman ki biz programÄ± Ã§alÄ±ÅŸtÄ±rÄ±rsak(yani compiler tarafÄ±ndan derlendikten sonra runtime olduÄŸu anda) o zaman bellekte alan ayrÄ±lÄ±r.  

int yas;
string adi;
string soyadi; 
kodu Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda, konsept (her bir ";" a kadar olan kÄ±smÄ± ifade eder.) ÅŸeklinde senkron olarak bellekte tutulur. Stack LIFO (Last In First Out) mantÄ±ÄŸÄ±na gÃ¶re Ã§alÄ±ÅŸÄ±r. Yani Son giren ilk Ã§Ä±kar.

ğŸ‘‰ ! LIFO, Ram'in doÄŸrudan Ã§alÄ±ÅŸma ÅŸekli deÄŸil, bellek yÃ¶netimi algoritmalarÄ±nÄ±n Ã¶zelliÄŸidir.

![43](https://github.com/user-attachments/assets/a23a455f-e899-422b-9c26-e9d6bfdc9d0f)

ğŸ‘‹ 44 - DeÄŸiÅŸken TanÄ±mlama KurallarÄ± 

DeÄŸiÅŸken isimleri yazÄ±lÄ±m sÃ¼recinde developer aÃ§Ä±sÄ±ndan bir karÄ±ÅŸÄ±klÄ±ÄŸa mahal vermemek iÃ§in anlamlÄ± olmalÄ±dÄ±r.

1- AnlamlÄ± Ä°simlendirme : DeÄŸiÅŸken isimlendirmede tutacaÄŸÄ±m deÄŸerin anlamÄ±nÄ± ifade eden deÄŸiÅŸken isimlendirmeleri kullanmak yaÄ±zlÄ±m geliÅŸtirme sÃ¼recinde developer iÃ§in faydalÄ± olacaktÄ±r.
 
2- Ã–zel Karakter KullanÄ±lmamalÄ± : DeÄŸiÅŸken isimlendirmelerinde (, . ;) gibi Ã¶zel karakterler kullanÄ±lmaz. "_" ise istisnai bir durumdur.

3- SayÄ± Durumuna GÃ¶re KullanÄ±mlar : DeÄŸiÅŸken isimlendirmede sayÄ± kullanÄ±lmak istenirse deÄŸiÅŸkenin adÄ±na sayÄ± ile baÅŸlayamazsÄ±n ama deÄŸiÅŸken adÄ± iÃ§inde sayÄ± kullanabilirsin. "1sayi" yanlÄ±ÅŸ bir kullanÄ±mken "sayi1"" doÄŸru kullanÄ±mdÄ±r. 

ğŸ‘‰ ! Bir scope iÃ§inde birden fazla aynÄ± isimde deÄŸiÅŸken tanÄ±mlanamaz.

ğŸ‘‹ 45 - Ä°simlendirme KurallarÄ± - Name Convention - Pascal Case - Camel Case - Snake Case 

Pascal Case : Her kelimenin ilk harfi bÃ¼yÃ¼k yazÄ±lÄ±r. KÄ±saltma iki harfli ise her 
iki harfte bÃ¼yÃ¼k yazÄ±lÄ±r. In/Out -> IO, InOutStream -> IOStream ÅŸeklinde yazÄ±lÄ±r.

Camel Case : Ä°lk kelime kÃ¼Ã§Ã¼k diÄŸerleri bÃ¼yÃ¼k yazÄ±lÄ±r. 

![45](https://github.com/user-attachments/assets/4a8181e9-591f-43f2-8b13-bcb8b073c09e)

Snake Case : Ä°lk kelime kÃ¼Ã§Ã¼k diÄŸerleri bÃ¼yÃ¼k yazÄ±lÄ±r.


ğŸ‘‹ 46 - DeÄŸiÅŸken Ä°simlerini "@" OperatorÃ¼yle TanÄ±mlama

Normalde bir deÄŸiÅŸken tanÄ±mlanÄ±rken, deÄŸiÅŸken ismi iÃ§in programatik keyword kullanÄ±lmaz. EÄŸer programatik keyword deÄŸiÅŸken adÄ± olarak kullanÄ±lmak istenirse bunu programa, bu bir keyword deÄŸildir ÅŸeklinde bildirmemiz gerekiyor. Ä°ÅŸte "@" operatorÃ¼ ile keyword kullanÄ±rsak bunun bir programatik keyword olmadÄ±ÄŸÄ±nÄ±, bizim tÄ±pkÄ± "age" "name" ÅŸeklinde kullanabileceÄŸimiz normal bir deÄŸiÅŸken ismi gibi deÄŸiÅŸken adÄ± tanÄ±mladÄ±ÄŸÄ±mÄ±zÄ± sÃ¶ylemiÅŸ/belirtmiÅŸ oluruz. 

string name; //normal bir kullanÄ±mdÄ±r.
string @string; // C#'ta metinsel ifadeleri tanÄ±mlamada kullanÄ±lan bir keyword olan "string" kelimesi normal bir deÄŸiÅŸken ismi gibi "@" kullanÄ±larak belirtilmiÅŸtir. 

ğŸ‘‹ 47 - TanÄ±mlanmÄ±ÅŸ DeÄŸiÅŸkene DeÄŸer Atama

DeÄŸiÅŸkene tanÄ±mlandÄ±ktan sonra deÄŸer atanÄ±r. TanÄ±mlanan deÄŸiÅŸken, belleÄŸin stack kÄ±smÄ±nda, deÄŸer tÃ¼rlÃ¼ deÄŸiÅŸkenlerin (tek 1 deÄŸeri olan, nesne olmayan) tÃ¼rÃ¼, adÄ± ve deÄŸerleri ile tutulur. EÄŸer tanÄ±mlama esnasÄ±nda deÄŸiÅŸkene deÄŸer atamak istersem, "int number = 5;" konsepti kullanÄ±lÄ±r, burada "=" ifadesi atama(assign) opratorÃ¼dÃ¼r. Assign operatorÃ¼, saÄŸdaki deÄŸeri soldakine atar. Bir deÄŸiÅŸkene deÄŸer atanacaksa kesinlikle deÄŸiÅŸken solda, atanacak deÄŸer saÄŸda olmalÄ±dÄ±r.

![47](https://github.com/user-attachments/assets/7ceecc72-d70f-48ae-ab10-9ae549c2ac42)

EÄŸer ki deÄŸiÅŸken ismi assign operatorÃ¼nÃ¼n solunda kalÄ±yorsa o alana deÄŸiÅŸkenin kendisi gelecektir. Tam tersi durum olursa deÄŸiÅŸken ismi saÄŸda olursa bu defa sol tarafa deÄŸiÅŸkenin deÄŸeri gidecektir.

int x;
...
x = 120; 
Bu Ã¶rnekte, "int" tÃ¼rÃ¼nde "x" adÄ±nda ramde alan tahisi edildi. Daha sonra dedik ki bu x deÄŸiÅŸkenini getir.  O alana git ve deÄŸerine 120 ata. EÄŸer "x" assign solundaysa kendisi gelecekti. Kendisi ve deÄŸeri gitmesi farklÄ± ÅŸeyler!

![47-2](https://github.com/user-attachments/assets/c02557ef-0f4c-442e-93ba-fd1f219393f6)
 
ğŸ‘‰ ! Bir deÄŸiÅŸkenin deÄŸerinde en son deÄŸer geÃ§erlidir. Yani bir deÄŸiÅŸkene birden fazla deÄŸer atayabilirim ve atadÄ±ÄŸÄ±m en son deÄŸer geÃ§erlidir. Ã–nceki deÄŸerler ezilecektir/yok sayÄ±lacaktÄ±r/geÃ§ersiz olacaktÄ±r.

int a = 5;
a = 15;
a = 20;
Ã¶rneÄŸe gÃ¶re var olan a deÄŸiÅŸkei Ã¶aÄŸÄ±rÄ±lÄ±p deÄŸeri deÄŸiÅŸir, yeni bir a oluÅŸmaz ve deÄŸiÅŸkenin son deÄŸeri 20 olur.

![47-3](https://github.com/user-attachments/assets/3a8f00f3-be21-4bff-b25d-31be480462d5)

ğŸ‘‰ ! TanÄ±mlanmÄ±ÅŸ olan deÄŸiÅŸken tÃ¼rÃ¼ne gÃ¶re deÄŸer atanmalÄ±dÄ±r.

ğŸ‘‹ 48 - Bir DeÄŸiÅŸkene DeÄŸer Atama KurallarÄ±

DeÄŸiÅŸkenler tÃ¼rÃ¼ne gÃ¶re kategorize edilir. DÃ¶rt kategoride deÄŸer tÃ¼rleri vardÄ±r. Bunlar metinsel, karaktersel, mantÄ±ksal ve sayÄ±sal deÄŸerlerdir.

Metinsel deÄŸerler, string keywordu ile tutulur. Metinsel ifadeler "" iÃ§ine yazÄ±lÄ±r. Bir sayÄ±sal ifade ""(Ã§ift tÄ±rnak) iÃ§inde yazÄ±larak tutulursa yazÄ±lÄ±m aÃ§Ä±sÄ±ndan bu ifade metinsel ifade olarak kabul edilir ve tutulan sayÄ±sal deÄŸer Ã¼zerinde herhagi bir matematiksel iÅŸlem yapÄ±lamaz. "string sayi = 4;" gibi. 

Karakter deÄŸerleri ''(tek tÄ±rnak) iÃ§inde tutulur ve sadece tek bir karakteri tutar. (o ; 3) gibi.

MantÄ±ksal deÄŸerler bool tÃ¼rÃ¼nde tutulur. True(1) yada false (0) olarak belirtilir. "bool medeniDurum = false;" gibi.

SayÄ±sal deÄŸerler direkt olarak tutulur. 1000 sayÄ±sÄ±nÄ± tutmak istediÄŸimiz dÃ¼ÅŸÃ¼nelim. Peki bu hangi tÃ¼rde bir sayÄ±sal ifade olacaktÄ±r. SayÄ±sal ifadelerde bir deÄŸer default olarak "int" kabul edilir. Bir sayÄ±sal tÃ¼r deÄŸer aralÄ±ÄŸÄ±na girmeyen deÄŸeri tutamaz. Compiler hata verir. "int yas = 1000000000" hatalÄ± bir kullanÄ±mdÄ±r.
 
OndalÄ±klÄ± SayÄ±lar : TÃ¼m ondalÄ±klÄ± sayÄ±lar tam sayÄ±larÄ± karÅŸÄ±layabilir. OndalÄ±klÄ± sayÄ±lar, "float", "double" ve "decimal" tÃ¼rÃ¼nde tutulabilir. Ama kÃ¼sÃ¼ratlÄ± sayÄ±lar olmaya baÅŸlayÄ±nca sÄ±kÄ±ntÄ± olmaya baÅŸlÄ±yor.

Float : Float tÃ¼rÃ¼nde kÃ¼sÃ¼ratlÄ± bir deÄŸer tutarken ilgili deÄŸeri sonuna f yada F getirilir. "3.14f" yada "3.14F" gibi.

Double : Ä°lgiil deÄŸerin sonuna d yada D getirilir.  "3.14d" yada "3.14D" yada "3.14" gibi.

Decimal : Ä°lgili deÄŸiÅŸkenin sonuna m yada M getirilir. "3.14m" yada "3.14M" gibi.

ğŸ‘‹ 49 - (_a,_b) = (a,b) Tuple TÃ¼rÃ¼yle DeÄŸer Atama

Tek bir syntax ile birden fazla deÄŸiÅŸkeni tanÄ±mlamamÄ±zÄ± saÄŸlayan bir nesnedir. 
(int a, int b, type c, type d) z; burada tuple deÄŸiÅŸken tanÄ±mlamasÄ± yapÄ±lmÄ±ÅŸtÄ±r. z iÃ§inde , int type vs. olmak Ã¼zere birden fazla farklÄ± yada benzer tÃ¼rde deÄŸiÅŸken tanÄ±mÄ± yapÄ±lÄ±r. Yani tuple birden fazla deÄŸiÅŸken tutar ve bu deÄŸiÅŸkenlerinde deÄŸerleri olacak. Bunlasr yine stackte tutulacak. 

ğŸ‘‰ ! Tuple, deÄŸiÅŸkene deÄŸer atama tÃ¼rÃ¼dÃ¼r.

ÅÃ¶yle ki, C# dilinde tuple'lar kullanÄ±larak birden fazla deÄŸeri tek bir deÄŸiÅŸken iÃ§inde gruplayabiliriz. (int a, int b) c = (3,5); Bu durumda, c adÄ±nda bir tuple tanÄ±mlanÄ±r ve iÃ§inde ik tam sayÄ± deÄŸeri saklar. Bu tuple, stack belleÄŸinde oluÅŸturulur. a ve b isimli iki tamsayÄ± deÄŸiÅŸkeni gibi davranÄ±r ve tuple iÃ§inde 3 ve 5 deÄŸerleri atanÄ±r. C#'ta tuple'lar genellikle kÃ¼Ã§Ã¼k veri yapÄ±larÄ±nÄ± temsil etmek iÃ§in kullanÄ±lÄ±r ve bu nedenle genellikle stack belleÄŸinde saklanÄ±rlar. Ancak, bÃ¼yÃ¼k tuple'lar veya tuple'lar bir koleksiyonun iÃ§inde kullanÄ±ldÄ±ÄŸÄ±nda heap belleÄŸinde saklanabilirler. Tuple'Ä±n boyutu ve iÃ§eriÄŸi ramde saklanacak davranÄ±ÅŸÄ± etkileyebilir. 

Tuple nesnesi, iÃ§ine bir veya dah afazla deÄŸiÅŸken tanÄ±mlayabildiÄŸimiz tek bir tanÄ±mlÄ±k nesnedir. (int a, string b) c = (5,  "ali"); burada atamalar da sÄ±rayla oluyor. a'ya be b'ye eriÅŸim saÄŸlamak iÃ§in c. ile eriÅŸiyoruz. 

![49](https://github.com/user-attachments/assets/f992b5f4-cb8b-49eb-8a78-f9c85478356c)

Tuple, C# 7.0 programlama dilinde bir veri yapÄ±sÄ±dÄ±r. Tuple, farklÄ± veri tiplerinden oluÅŸan, sabit uzunlukta ve deÄŸerleri deÄŸiÅŸtirilemeyen(immutable) bir koleksiyondur.

ğŸ‘‰ ! Tuple bir nesnedir. C#'ta her ÅŸey bir nesnedir ve Tuple da System.Object sÄ±nÄ±fÄ±ndan tÃ¼remiÅŸtir.

DeÄŸerleri deÄŸiÅŸtirilemezdir. (immutable)
FarklÄ± veri tipleri iÃ§erebilir.
Eleman sayÄ±sÄ± oluÅŸturulduÄŸunda sabittir.
Elemanlara Item1, Item2... ÅŸeklinde eriÅŸilir.

Tuple<int, string> person = new Tuple<int, string>(25,"ali );
int age = person.Item1;

ValueType adÄ±nda struct kullanÄ±lmaya baÅŸlayÄ±nca;
(int Age, string Name) person = (25, "ali");
Console.WriteLine($"Age: {person.Age}");

Maximum 8 Ã¶ÄŸe iÃ§erebilir. Daha fazlasÄ± iÃ§in iÃ§ iÃ§e Tuple'lar kullanÄ±labilir.
Orijinal Tuple'larda Ã¶ÄŸelere anlamlÄ± isimler verilmez. Item1, Item2 ...

Tuple, bir referans tipidir. Yani heap belleÄŸinde saklanÄ±r. Bu, bÃ¼yÃ¼k miktarlarda kullanÄ±ldÄ±ÄŸÄ±nda performans aÃ§Ä±sÄ±ndan dezavantaj olabilir.

âœ¨ Tuple'Ä±n Nesne OlmasÄ± : Tuple bir nesnedir, ancak sadece System.Object'te tÃ¼rediÄŸi iÃ§in deÄŸil. C#'ta her ÅŸey(deÄŸer tipleri dahil) en temel seviyede Object sÄ±nÄ±fÄ±ndan tÃ¼rer. Tuple bir nesnedir Ã§Ã¼nkÃ¼, 
Referans tiplidir.
Heap'te depolanÄ±r.
Garbage collection'a tabidir.
 
âœ¨ Koleksiyon ve Nesne FarkÄ± : 
Nesne, veri ve davranÄ±ÅŸalrÄ±(metotlarÄ±) kapsÃ¼lleyen bir yapÄ±dÄ±r.
Koleksiyon, birden fazla nesneyi veya deÄŸeri iÃ§eren bir veri yapÄ±sÄ±dÄ±r. 
Yani bir koleksiyon aynÄ± zmanada bir nesnedir. Tuple, hem bir nesne hem de bir koleksiyon olarak dÃ¼ÅŸÃ¼nÃ¼lebilir.
 
âœ¨ Tuple'Ä±n Heap'te TutulmasÄ± :
Tuple heap'te tutulur. Ã‡Ã¼nkÃ¼, 
 * Referans Tipi - Tuple bir referans tipidir. C#'ta tÃ¼m referans tipelri heap'te depolanÄ±r.
 * DeÄŸiÅŸken Boyutu - Tuple'lar farklÄ± boyutlarda olabilir ve farklÄ± tiplerde veriler iÃ§erebilir. Heap, bu tÃ¼r deÄŸiÅŸken boyutlu ve karmaÅŸÄ±k yapÄ±lar iÃ§in uygundur.
 * YaÅŸam SÃ¼resi - Heap'teki nesneler, referanslarÄ± olduÄŸu sÃ¼rece yaÅŸarlar ve garbage collector tarafÄ±ndan yÃ¶netilirler. Bu, Tuple'larÄ±n metot Ã§aÄŸrÄ±larÄ± arasÄ±nda bil evarlÄ±kalrÄ±nÄ± sÃ¼rdÃ¼rmelerine olanak tanÄ±r.
 * Esneklik - Heap dinamik bellek tahsisi saÄŸlar, bu da Tuple gibi yapÄ±larÄ±n runtime'da oluÅŸturulmasÄ±na ve yÃ¶netilmesine izin verir.

âœ¨ Stack'te TutulmamasÄ±nÄ±n Nedenleri:
Stack, genellikle sabit boyutlu ve kÄ±sa Ã¶mÃ¼rlÃ¼ veriler iÃ§in kullanÄ±lÄ±r.
Stack'in boyutu sÄ±nÄ±rlÄ±dÄ±r ve bÃ¼yÃ¼k veya karmaÅŸÄ±k nesneler iÃ§i uygun deÄŸildir.
Stack'teki veriler metot Ã§aÄŸrÄ±alrÄ± arasÄ±nda otomatik olarak temizlenir, bu da Tuple gibi daha uzun Ã¶mÃ¼rlÃ¼ olabilen yapÄ±ar iÃ§in uygun deÄŸildir.

ğŸ‘‰ ! C# 7.0 ile birlikte gelen valueTuple, Tuple'Ä±n bir deÄŸer tipi versiyonudur ve stack'te tutulur. 
